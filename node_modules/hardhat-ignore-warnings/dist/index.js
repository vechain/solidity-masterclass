"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WarningClassifier = void 0;
const plugins_1 = require("hardhat/plugins");
const minimatch_1 = __importDefault(require("minimatch"));
const node_interval_tree_1 = __importDefault(require("node-interval-tree"));
const solidity_comments_1 = require("solidity-comments");
const error_codes_1 = require("./error-codes");
const defaultRule = 'warn';
class WarningClassifier {
    constructor(config) {
        this.config = config;
        this.ignoreRanges = {};
        this.rules = (0, plugins_1.lazyObject)(() => sortFileRules(config));
    }
    getWarningRule(errorCode, sourceLocation) {
        const { file, start } = sourceLocation;
        const ignored = errorCode !== undefined && this.ignoreRanges[file]?.search(start, start).includes(errorCode);
        if (ignored) {
            return 'off';
        }
        for (const rule of this.rules) {
            if ((0, minimatch_1.default)(file, rule.pattern, { matchBase: true })) {
                const r = (errorCode !== undefined && rule.rules[errorCode]) || rule.rules.default;
                if (r)
                    return r;
            }
        }
        return defaultRule;
    }
    reprocessFile(file, contents) {
        const ranges = [];
        const { comments } = (0, solidity_comments_1.analyze)(contents);
        const buf = Buffer.from(contents, 'utf8');
        for (const c of comments) {
            const t = c.text.replace(/^\/\/\s+/, '');
            const m = t.match(/^solc-ignore-next-line (.*)/);
            if (m) {
                const ids = m[1].trim().split(/\s+/);
                const lineEnd = buf.toString('utf8', c.end, c.end + 2);
                const start = c.end + (lineEnd === '\r\n' ? 2 : 1);
                const nextNewline = buf.indexOf('\n', start);
                const end = nextNewline >= 0 ? nextNewline : buf.length;
                for (const id of ids) {
                    const code = (0, error_codes_1.getErrorCode)(id);
                    ranges.push({ start, end, code });
                }
            }
        }
        if (ranges.length === 0) {
            delete this.ignoreRanges[file];
        }
        else {
            const tree = this.ignoreRanges[file] = new node_interval_tree_1.default();
            for (const { start, end, code } of ranges) {
                tree.insert(start, end, code);
            }
        }
    }
}
exports.WarningClassifier = WarningClassifier;
const normalizeWarningRule = (r, def = 'warn') => r === true ? def : r === false ? 'off' : r;
function normalizeFileRules(rules) {
    if (typeof rules === 'object') {
        const def = normalizeWarningRule(rules.default);
        const res = {};
        for (const [id, r] of Object.entries(rules)) {
            const code = id === 'default' ? id : (0, error_codes_1.getErrorCode)(id);
            res[code] = normalizeWarningRule(r, def);
        }
        return res;
    }
    else {
        return {
            default: normalizeWarningRule(rules),
        };
    }
}
function sortFileRules(config) {
    const rules = Object.entries(config).map(([pattern, rules]) => ({ pattern, rules: normalizeFileRules(rules) }));
    rules.sort((a, b) => ((0, minimatch_1.default)(a.pattern, b.pattern, { matchBase: true })
        ? -1
        : (0, minimatch_1.default)(b.pattern, a.pattern, { matchBase: true })
            ? +1
            : 0));
    return rules;
}
//# sourceMappingURL=index.js.map