import * as s_bip32 from '@scure/bip32';
import { AbiParameter, AbiFunction, AbiEvent, Abi, ContractEventName, DecodeEventLogReturnType, EncodeEventTopicsReturnType, ContractFunctionName, DecodeFunctionDataReturnType, DecodeFunctionResultReturnType } from 'viem';
import { Input, NestedUint8Array } from '@ethereumjs/rlp';

/**
 * In the VeChainThor blockchain, a certificate is a data structure used
 * for client-side self-signed certificates.
 * It plays a crucial role in providing a mechanism for secure identification
 * and validation of data.
 *
 * Certificates are primarily used for purposes like attestation, validation,
 * and verification of data authenticity.
 * They are used as proofs of authenticity and origin for data exchanged
 * within the VeChain ecosystem.
 */
interface CertificateData {
    /**
     * The purpose field indicates the intended use or context of the certificate.
     * For example, it could be used for identification, verification,
     * or attestation.
     */
    purpose: string;

    /**
     * The payload field holds the actual content of the certificate.
     * This content can be of various types, such as text, images, or other data.
     */
    payload: {
        type: string;
        content: string;
    };

    /**
     * The domain field represents the specific context or domain
     * for which the certificate is valid.
     * It helps ensure that the certificate is only applicable
     * within the intended context.
     */
    domain: string;

    /**
     * The timestamp field records the time at which the certificate
     * was created or issued.
     * This provides a temporal reference for the certificate's validity.
     *
     * The value is expressed as of milliseconds elapsed since the
     * [epoch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#the_epoch_timestamps_and_invalid_date),
     * which is defined as the midnight at the beginning of January 1, 1970, UTC.
     *
     * @remarks
     * The value is a natural number in the safe integer range of JS `number` type.
     */
    timestamp: number;

    /**
     * The signer field indicates the address of the entity
     * that signs the certificate.
     * It is the public key address of the entity that issues the certificate.
     */
    signer: string;

    /**
     * The signature field contains the cryptographic signature
     * generated by the issuer's private key.
     * This signature ensures the integrity and authenticity
     * of the certificate's content.
     *
     * @remarks
     * The signature is a lowercase hexadecimal expression prefixed with `0x`.
     */
    signature?: string;
}

/**
 * The Certificate class provides functionality to create, sign, and verify certificates.
 * It implements the CertificateData interface.
 *
 * @remarks
 * The properties of those class are immutable, except {@link signature},
 * because properties are part of the {@link signature} computation.
 * The signature is used of extract and match the {@link signer}.
 * The fact the properties are immutable assure is not possible to create
 * an object tampering properties and carry on the legitimate signature and
 * signer address of the object before tampering to make tampered content
 * to result in a validated certificate.
 *
 * @remarks
 * Classes extending {@link Certificate} should expose immutable properties.
 *
 * @remarks
 * This class implementation supports {@link signer}
 * [mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).
 *
 * @implements CertificateData
 */
declare class Certificate implements CertificateData {
    /**
     * Return the intended use or context of the certificate.
     */
    readonly purpose: string;
    /**
     * Returns the content of the certificate.
     */
    readonly payload: {
        /**
         * Return the description of the type of content.
         */
        readonly type: string;
        /**
         * Return the content serialized as a string.
         */
        readonly content: string;
    };
    /**
     * Return the description of the context of validity of this certificate.
     */
    readonly domain: string;
    /**
     * The value expressed as of milliseconds elapsed since the
     * [epoch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#the_epoch_timestamps_and_invalid_date),
     * when the certificate was issued.
     *
     * @remarks
     * The value is a natural number in the safe integer range of JS `number` type.
     */
    readonly timestamp: number;
    /**
     * Return the address of the entity signed the certificate, as
     * a lowercase hexadecimal expression prefixed by `0x`.
     *
     * @remarks
     * Normalized lowercase prefixed expression is needed because
     * the content of this property is part of the {@signature} computation:
     * certificates made from checksum case address of the signer should
     * result valid as the certificate made from the same signer address
     * not checksum case.
     */
    readonly signer: string;
    /**
     * Return the signature computed evaluating the properties of this object
     * and the private key of the signer.
     *
     * @remarks
     * The signature is a lowercase hexadecimal expression prefixed with `0x`.
     */
    signature?: string;
    /**
     * Returns a new instance of this class assuring the formal validity of the
     * arguments used to build the object.
     *
     * @param {string} purpose - The purpose of the certificate.
     * @param {Object} payload - The payload containing type and content.
     * @param {string} payload.type - The type of the payload.
     * @param {string} payload.content - The content of the payload.
     * @param {string} domain - The domain associated with the certificate.
     * @param {number} timestamp - The time at which the certificate is created;
     * must be a positive safe integer.
     * @param {string} signer - The signer of the certificate;
     * must be a valid address.
     * @param {string|undefined} [signature] - The signature of the certificate;
     * optional parameter.
     *
     * @throws {InvalidDataType} If timestamp is not a positive safe integer.
     * @throws {InvalidDataType} If signer is not a valid address.
     * @throws {InvalidDataType} If signature is invalid.
     *
     * @remarks
     * The `signer` address is represented lowercase and `0x` prefixed.
     */
    protected constructor(purpose: string, payload: {
        type: string;
        content: string;
    }, domain: string, timestamp: number, signer: string, signature?: string);
    /**
     * Encodes a given object into a Uint8Array representation
     * applying the following operation to normalize the content:
     * - the properties are sorted in ascending alphabetic order;
     * - the key/value properties are delimited with `"` when serialized as JSON
     *   before to be encoded as bytes;
     * - any not meaningful blank characters are ignored;
     * - the JSON representation of this object is byte encoded using the UTF-8
     *   [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms).
     *
     * @param {unknown} object - The input object to be encoded.
     * @return {Uint8Array} The encoded Uint8Array representation of the input object.
     */
    protected static encode(object: unknown): Uint8Array;
    /**
     * Encodes the current certificate instance into a Uint8Array representation.
     *
     * @remarks
     * This method normalizes the content by:
     * - Sorting the properties in ascending alphabetic order.
     * - Delimiting key/value properties with `"` when serialized as JSON before encoding as bytes.
     * - Ignoring any not meaningful blank characters.
     * - Using the UTF-8 normalization form for canonical composition for byte encoding.
     *
     * @return {Uint8Array} The encoded Uint8Array representation of the current certificate instance.
     */
    encode(): Uint8Array;
    /**
     * Return `true` if the current instance has a signature.
     *
     * @return {boolean} `true` if the signature is a valid hexadecimal string,
     * otherwise `false`.
     */
    isSigned(): boolean;
    /**
     * Creates a new Certificate instance from the provided CertificateData.
     *
     * @param {CertificateData} data - The data required to create the Certificate.
     * @return {Certificate} A new Certificate instance.
     * @throws {InvalidDataType} If the provided data is invalid:
     * - if timestamp is not a positive safe integer;
     * - if signer is not a valid address;
     * - if signature is an invalid hexadecimal expression.
     *
     * @remarks
     * This method supports {@link signer}
     * [mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).
     *
     * @see constructor
     */
    static of(data: CertificateData): Certificate;
    /**
     * Signs the current object using a given private key.
     *
     * The {@link signature} is computed encoding this object according
     * the following normalization rules:
     * - the {@link signature} property is ignored, because its value
     *   is the result of this method.
     * - the properties are sorted in ascending alphabetic order;
     * - the key/value properties are delimited with `"` when serialized as JSON
     *   before to be encoded as bytes;
     * - any not meaningful blank characters are ignored;
     * - the JSON representation of this object is byte encoded using the UTF-8
     *   [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms).
     *
     * @param {Uint8Array} privateKey - The private key used for signing.
     * @return {this} The current instance after signing.
     *
     * @throws {InvalidOperation} - If a hash error occurs.
     * @throws {InvalidSecp256k1PrivateKey} - If the private key is not a valid 32-byte private key.
     *
     * @remarks Security auditable method, depends on
     * * {@link Blake2b256.of};
     * * {@link Secp256k1.sign}.
     *
     * @see encode
     * @see verify
     */
    sign(privateKey: Uint8Array): this;
    /**
     * Verifies the certificate by checking its signature.
     *
     * @throws {CertificateSignatureMismatch} if the certificate
     * - is not signed, or
     * - the signature does not match the signer's public key.
     *
     * @remarks
     * This method supports {@link signer}
     * [mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).
     *
     * @remarks Security auditable method, depends on
     * * {@link Blake2b256.of};
     * * {@link Secp256k1.recover}.
     */
    verify(): void;
}

/**
 * This class extends the
 * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
 * [HDKey](https://github.com/paulmillr/scure-bip32) class
 * to provide interoperability with
 * [ethers.js 6 HDNodeWallet](https://docs.ethers.org/v6/api/wallet/#HDNodeWallet).
 *
 * @extends s_bip32.HDKey
 */
declare class HDKey extends s_bip32.HDKey {
    /**
     * Prefix for extended private key
     */
    static readonly EXTENDED_PRIVATE_KEY_PREFIX: Uint8Array;
    /**
     * Prefix for extended public key
     */
    static readonly EXTENDED_PUBLIC_KEY_PREFIX: Uint8Array;
    /**
     * Default VET derivation path.
     *
     * See
     * [SLIP-0044 : Registered coin types for BIP-0044](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
     * for more info.
     */
    static readonly VET_DERIVATION_PATH = "m/44'/818'/0'/0";
    /**
     * Creates a
     * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     * from
     * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
     * and the given derivation path.
     *
     * @param {string[]} words - An array of words representing the mnemonic.
     * @param {string} path - The derivation path to derive the child node.
     * Default value is {@link VET_DERIVATION_PATH}.
     *
     * @return The derived child hierarchical deterministic key.
     *
     * @throws {InvalidHDKey} If `path` is not valid to derive a node wallet.
     * @throws {InvalidHDKeyMnemonic} If `words` is an invalid array mnemonic.
     *
     * @remarks Security auditable method, depends on
     * * [s_bip32.HDKey.derive](https://github.com/paulmillr/scure-bip32);
     * * [s_bip32.HDKey.fromMasterSeed](https://github.com/paulmillr/scure-bip32);
     * * [s_bip39.mnemonicToSeedSync](https://github.com/paulmillr/scure-bip39).
     */
    static fromMnemonic(words: string[], path?: string): HDKey;
    /**
     * Creates a
     * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     * from a private key and chain code.
     *
     * @param {Uint8Array} - privateKey The private key.
     * @param {Uint8Array} - chainCode The chain code.
     *
     * @returns Returns the hierarchical deterministic key from `privateKey` and `chainCode`.
     *
     * @throws {InvalidSecp256k1PrivateKey} If the `privateKey` is invalid.
     *
     * @remarks **This method wipes `privateKey`** for security reasons.
     * @remarks Security auditable method, depends on
     * * [base58.encode](https://github.com/paulmillr/scure-base);
     * * {@link Sha256};
     * * [s_bip32.HDKey.fromExtendedKey](https://github.com/paulmillr/scure-bip32).
     */
    static fromPrivateKey(privateKey: Uint8Array, chainCode: Uint8Array): HDKey;
    /**
     * Creates a
     * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     * key from a public key and chain code.
     *
     * @param {Uint8Array} publicKey - The public key bytes.
     * @param {Uint8Array} chainCode - The chain code bytes.
     *
     * @returns {HDKey} Returns the hierarchical deterministic key from `public` and `chainCode`.
     *
     * @throws {InvalidHDKey} if the `publicKey` is invalid.
     *
     * @remarks Security auditable method, depends on
     * * [base58.encode](https://github.com/paulmillr/scure-base);
     * * {@link Secp256k1.compressPublicKey};
     * * {@link Sha256};
     * * [HDKey.fromExtendedKey](https://github.com/paulmillr/scure-bip32).
     */
    static fromPublicKey(publicKey: Uint8Array, chainCode: Uint8Array): HDKey;
    /**
     * Checks if derivation path single component is valid
     *
     * @param component - Derivation path single component to check
     * @param index - Derivation path single component index
     *
     * @returns `true`` if derivation path single component is valid, otherwise `false`.
     *
     */
    private static isDerivationPathComponentValid;
    /**
     * Checks if derivation path is valid.
     *
     * @param derivationPath - Derivation path to check.
     *
     * @returns `true` if derivation path is valid, otherwise `false`.
     */
    static isDerivationPathValid(derivationPath: string): boolean;
}

/**
 * @interface Keystore
 * Represents a
 * [Web3 Secret Storage](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage)
 * keystore object that holds information about a private cryptographic key.
 * and its associated wallet address.
 *
 * @property {string} address - The wallet address associated with the stored private key.
 * @property {Object} crypto - The encryption information for the key.
 * @property {string} crypto.cipher - The encryption algorithm used.
 * @property {Object} crypto.cipherparams - Additional parameters for the encryption algorithm.
 * @property {string} crypto.cipherparams.iv - The initialization vector (IV) used for encryption.
 * @property {string} crypto.ciphertext - The encrypted private key.
 * @property {string} crypto.kdf - The key derivation function (KDF) used.
 * @property {Object} crypto.kdfparams - Additional parameters for the KDF.
 * @property {number} crypto.kdfparams.dklen - The derived private key length.
 * @property {number} crypto.kdfparams.n - The CPU/memory cost parameter for the key derivation function.
 * @property {number} crypto.kdfparams.p - The parallelization factor.
 * @property {number} crypto.kdfparams.r - The block size factor.
 * @property {string} crypto.kdfparams.salt - The salt value used in the KDF.
 * @property {string} crypto.mac - The MAC (Message Authentication Code)
 * to match the KDF function with the private key derived by the cyphered text stored.
 * @property {string} id - The
 * [unique identifier version 4](https://en.wikipedia.org/wiki/Universally_unique_identifier)
 * for the key store.
 * @property {number} version - The version number of the key store.
 */
interface Keystore {
    address: string;
    crypto: {
        cipher: string;
        cipherparams: {
            iv: string;
        };
        ciphertext: string;
        kdf: string;
        kdfparams: {
            dklen: number;
            n: number;
            p: number;
            r: number;
            salt: string;
        };
        mac: string;
    };
    id: string;
    version: number;
}

/**
 * Interface representing a keystore account.
 *
 * **WARNING:** call
 * ```javascript
 * privateKey.fill(0)
 * ```
 * after use to avoid to invalidate any security audit and certification granted to this code.
 *
 * @property {string} address - The address associated with the account.
 * @property {Uint8Array} privateKey - The private key associated with the account.
 *
 * @remarks **Differently from
 * [ethers KeystoreAccount](https://github.com/ethers-io/ethers.js/blob/main/src.ts/wallet/json-keystore.ts),
 * this type represents the private key as a buffer of bytes to avoid
 * [Memory Dumping](https://github.com/paulmillr/noble-hashes?tab=readme-ov-file#memory-dumping)
 * attack.**
 */
interface KeystoreAccount {
    address: string;
    privateKey: string;
    // @NOTE: Added ONLY for compatibility with ethers KeystoreAccount of ethers.
    mnemonic?: {
        path?: string;
        locale?: string;
        entropy: string;
    };
}

/**
 * Sets the keystore cryptography to experimental mode.
 *
 * @param experimentalCryptography - A boolean indicating whether the keystore cryptography is experimental or not.
 */
declare function useExperimentalCryptography(experimentalCryptography: boolean): void;
/**
 * Encrypts a given private key into a keystore format using the specified password.
 *
 * @param privateKey - The private key to be encrypted.
 * @param password - The password used for the encryption.
 * @returns A Promise that resolves to the encrypted keystore.
 */
declare function encrypt(privateKey: Uint8Array, password: string): Promise<Keystore>;
/**
 * Decrypts a keystore to obtain the private key using the given password.
 *
 * @throws {InvalidKeystoreError, InvalidKeystorePasswordError}
 * @param keystore - The keystore containing the encrypted private key.
 * @param password - The password used to decrypt the keystore.
 * @returns A Promise that resolves to the decrypted KeystoreAccount or rejects if the keystore or password is invalid.
 */
declare function decrypt(keystore: Keystore, password: string): Promise<KeystoreAccount>;
/**
 * Validates if the provided keystore adheres to the expected format and structure.
 *
 * @param keystore - The keystore to be validated.
 * @returns A boolean indicating whether the keystore is valid or not.
 */
declare function isValid(keystore: Keystore): boolean;
/**
 * Exports the keystore functions for encryption, decryption, and validation.
 */
declare const keystore: {
    encrypt: typeof encrypt;
    decrypt: typeof decrypt;
    isValid: typeof isValid;
    useExperimentalCryptography: typeof useExperimentalCryptography;
};

/**
 * The Secp256k1 class provides cryptographic utilities for the
 * [SECP256K1](https://en.bitcoin.it/wiki/Secp256k1)
 * [elliptic curve](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm),
 * including compressing and inflating public keys,
 * generating private keys, and validating message hashes and private keys.
 */
declare class Secp256k1 {
    /**
     * This value is used to identify compressed public key.
     */
    private static readonly COMPRESSED_PREFIX;
    /**
     * Represents the fixed length of the cryptographic signature.
     * The value is set to 65, which is the size in bytes
     * required for a 520-bit signature.
     *
     * @constant {number} SIGNATURE_LENGTH
     */
    static readonly SIGNATURE_LENGTH = 65;
    /**
     * This value is used to identify uncompressed public key.
     */
    private static readonly UNCOMPRESS_PREFIX;
    /**
     * Defines the required length for a valid hash.
     */
    private static readonly VALID_HASH_LENGTH;
    /**
     * Compresses an uncompressed public key.
     *
     * @param {Uint8Array} publicKey - The uncompressed public key to be compressed.
     * @return {Uint8Array} - The compressed public key.
     *
     * @see Secp256k1.inflatePublicKey
     */
    static compressPublicKey(publicKey: Uint8Array): Uint8Array;
    /**
     * Derives the public key from a given private key.
     *
     * @param {Uint8Array} privateKey - The private key in Uint8Array format. Must be a valid 32-byte secp256k1 private key.
     * @param {boolean} [isCompressed=true] - Indicates whether the derived public key should be in compressed format.
     * @return {Uint8Array} The derived public key in Uint8Array format.
     * @throws {InvalidSecp256k1PrivateKey} Throws an error if the provided private key is not valid.
     *
     * @remarks Security auditable method, depends on
     * * [nc_secp256k1.getPublicKey](https://github.com/paulmillr/noble-secp256k1).
     */
    static derivePublicKey(privateKey: Uint8Array, isCompressed?: boolean): Uint8Array;
    /**
     * Generates a new random private key.
     * If an error occurs during generation using
     * [nc_secp256k1](https://github.com/paulmillr/noble-secp256k1),
     * an AES-GCM key is generated as a fallback in runtimes not supported
     * by `nc_secp256k1`, if those support {@link {@link global.crypto}.
     *
     * @return {Promise<Uint8Array>} The generated private key as a Uint8Array.
     *
     * @remarks Security auditable method, depends on
     * * {@link global.crypto.subtle.exportKey};
     * * {@link global.crypto.subtle.generateKey};
     * * [nc_secp256k1.utils.randomPrivateKey](https://github.com/paulmillr/noble-secp256k1).
     */
    static generatePrivateKey(): Promise<Uint8Array>;
    /**
     * Inflate a compressed public key to its uncompressed form.
     *
     * @param {Uint8Array} publicKey - The compressed public key to be inflated.
     * @return {Uint8Array} - The uncompressed public key.
     *
     * @remarks Security auditable method, depends on
     * * [nc_secp256k1.ProjectivePoint.fromAffine](https://github.com/paulmillr/noble-secp256k1);
     * * [nc_secp256k1.ProjectivePoint.fromHex](https://github.com/paulmillr/noble-secp256k1);
     * * [nc_secp256k1.ProjectivePoint.toAffine](https://github.com/paulmillr/noble-secp256k1).
     *
     * @see Secp256K1.compressPublicKey
     */
    static inflatePublicKey(publicKey: Uint8Array): Uint8Array;
    /**
     * Checks whether the provided hash is a valid message hash.
     *
     * @param {Uint8Array} hash - The hash to be validated.
     * @return {boolean} `true` if the hash is 32 bytes long, otherwise `false`.
     */
    static isValidMessageHash(hash: Uint8Array): boolean;
    /**
     * Checks if the provided private key is valid.
     *
     * @param {Uint8Array} privateKey - The private key to validate.
     * @return {boolean} `true` if the private key is valid, `false` otherwise.
     *
     * @remarks Security auditable method, depends on
     * * [nc_secp256k1.utils.isValidPrivateKey](https://github.com/paulmillr/noble-secp256k1).
     */
    static isValidPrivateKey(privateKey: Uint8Array): boolean;
    /**
     * Generates a random sequence of bytes.
     * If an error occurs during generation using
     * [nc_secp256k1](https://github.com/paulmillr/noble-secp256k1),
     * {@link {@link global.crypto} is used as fall back togenerate
     * the random sequence.
     *
     * @param {number} [bytesLength=32] - Optional. The number of random bytes to generate.
     * @return {Uint8Array} - A Uint8Array containing the random bytes.
     *
     * @remarks Security auditable method, depends on
     *  * {@link global.crypto.getRandomValues};
     * * [nh_randomBytes](https://github.com/paulmillr/noble-hashes).
     */
    static randomBytes(bytesLength?: number): Uint8Array;
    /**
     * Recovers the public key associated with the message hash from the given signature.
     *
     * @param {Uint8Array} messageHash - The 32-byte message hash to be verified.
     * @param {Uint8Array} sig - The 65-byte signature used for recovery, consisting of the compact signature and recovery byte.
     * @return {Uint8Array} The recovered public key in its raw bytes form.
     * @throws {InvalidSecp256k1MessageHash} If the provided message hash is invalid.
     * @throws {InvalidSecp256k1Signature} If the provided signature is not 65 bytes or contains an invalid recovery value.
     *
     * @remarks Security auditable method, depends on
     * * [nc_secp256k1.Signature](https://github.com/paulmillr/noble-secp256k1).
     *
     * @see Secp256k1.isValidMessageHash
     */
    static recover(messageHash: Uint8Array, sig: Uint8Array): Uint8Array;
    /**
     * Signs a given message hash using the provided private key.
     *
     * @param messageHash - A 32-byte message hash that needs to be signed.
     * @param privateKey - A 32-byte private key used for signing the message hash.
     * @return The signature of the message hash consisting of the r, s, and recovery values.
     * @throws InvalidSecp256k1MessageHash if the message hash is not a valid 32-byte hash.
     * @throws InvalidSecp256k1PrivateKey if the private key is not a valid 32-byte private key.
     *
     * @remarks Security auditable method, depends on
     * * [nc_secp256k1.sign](https://github.com/paulmillr/noble-secp256k1).
     *
     * @see Secp256k1.isValidMessageHash
     * @see Secp256k1.isValidPrivateKey
     */
    static sign(messageHash: Uint8Array, privateKey: Uint8Array): Uint8Array;
}

/**
 * Root interface for all the classes part of the `VeChain Data Model`
 * to provide a coherent API to represent, encode, and cast data among data types.
 *
 * @interface
 */
interface VeChainDataModel<T> {
    // Properties.
    /**
     * Return this instance cast to a big integer value
     * @throws InvalidOperation if this object can't cast to a big integer.
     */
    get bi(): bigint;

    /**
     * Return this instance cast to a buffer of bytes.
     */
    get bytes(): Uint8Array;

    /**
     * Return this object cast to number value.
     * @throws InvalidOperation if this object can't cast to a big integer.
     */
    get n(): number;

    // Methods.
    /**
     * Compare this instance with `that` in a lexicographic meaningful way.
     *
     * @param {T} that object to compare.
     * @return a negative number if `this` < `that`, zero if `this` = `that`, a positive number if `this` > that`.
     */
    compareTo: (that: T) => number;

    /**
     * Checks if the given value is equal to the current instance.
     *
     * @param {T} that - The value to compare.
     * @returns {boolean} - True if the values are equal, false otherwise.
     */
    isEqual: (that: T) => boolean;
}

/**
 * Represents a hexadecimal value expressed as
 * * `-` sign if the value is negative,
 * * `0x` hexadecimal notation tag,
 * * a not empty string of hexadecimal digits from `0` to `9` and from `a` to `f`.
 *
 * @description This hexadecimal notation is coherent with the decimal notation:
 * * the sign is only expressed for negative values, and it is always the first symbol,
 * * the `0x` tags the string as a hexadecimal expression,
 * * hexadecimal digits follow.
 * * An empty content results is no digits.
 *
 * @implements {VeChainDataModel<Hex>}
 */
declare class Hex implements VeChainDataModel<Hex> {
    /**
     * Negative multiplier of the {@link digits} absolute value.
     *
     * @type {number}
     */
    protected static readonly NEGATIVE: number;
    /**
     * Positive multiplier of the {@link digits} absolute value.
     *
     * @type {number}
     */
    protected static readonly POSITIVE: number;
    /**
     * A constant string prefix used in hexadecimal notation.
     */
    static readonly PREFIX = "0x";
    /**
     * The radix used for representing numbers base 16 in a positional numeral notation system.
     *
     * @typedef {number} RADIX
     */
    static readonly RADIX: number;
    /**
     * Regular expression for matching hexadecimal strings.
     * An empty input is represented as a empty digits.
     *
     * @type {RegExp}
     */
    private static readonly REGEX_HEX;
    /**
     * Regular expression pattern to match a prefix indicating hexadecimal number.
     *
     * @type {RegExp}
     */
    protected static readonly REGEX_HEX_PREFIX: RegExp;
    /**
     * Returns the hexadecimal digits expressing this absolute value, sign and `0x` prefix omitted.

     * @remarks An empty content results in an empty string returned.
     */
    readonly digits: string;
    /**
     * Represents the sign multiplier of a given number:
     * * {@link NEGATIVE} `-1` if negative,
     * * {@link POSITIVE} `1` if positive.
     */
    readonly sign: number;
    /**
     * Creates a new instance of this class to represent the value
     * built multiplying `sign` for the absolute value expressed by the hexadecimal `digits`.
     *
     * @param {number} sign - The sign of the value.
     * @param {string} digits - The digits of the absolute value in hexadecimal base.
     * @param {function} [normalize] - The function used to normalize the digits. Defaults to converting digits to lowercase.
     */
    protected constructor(sign: number, digits: string, normalize?: (digits: string) => string);
    /**
     * Returns the absolute value of this Hex object.
     *
     * @return {Hex} A new Hex object representing the absolute value of this Hex.
     */
    get abs(): Hex;
    /**
     * Returns the value of `bi` as a `BigInt` type.
     *
     * @returns {bigint} The value of `bi` as a `BigInt`.
     */
    get bi(): bigint;
    /**
     * Returns the Uint8Array representation of the aligned bytes.
     *
     * @return {Uint8Array} The Uint8Array representation of the aligned bytes.
     */
    get bytes(): Uint8Array;
    /**
     * Returns the value of n.
     *
     * @return {number} The value of n.
     *
     * @throws {InvalidOperation<Hex>} Throws an error if this instance doesn't represent
     * an [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
     */
    get n(): number;
    /**
     * Aligns the hexadecimal string to bytes by adding a leading '0' if the string length is odd.
     *
     * @returns {Hex} - The aligned hexadecimal string.
     */
    alignToBytes(): Hex;
    /**
     * Compares the current Hex object with another Hex object.
     *
     * @param {Hex} that - The Hex object to compare with.
     *
     * @return {number} - Returns a negative number if the current Hex object is less than the given Hex object,
     *                    zero if they are equal, or a positive number if the current Hex object is greater than the given Hex object.
     */
    compareTo(that: Hex): number;
    /**
     * Returns a new instance of the Hex class, its value fits to the specified number of digits.
     *
     * @param {number} digits - The number of digits to fit the Hex value into.
     *
     * @returns {Hex} - A new Hex instance that represents the fitted Hex value.
     *
     * @throws {InvalidDataType} - If the Hex value cannot be fit into the specified number of digits.
     */
    fit(digits: number): Hex;
    /**
     * Determines whether this Hex instance is equal to the given Hex instance.
     *
     * @param {Hex} that - The Hex instance to compare with.
     * @return {boolean} - True if the Hex instances are equal, otherwise false.
     */
    isEqual(that: Hex): boolean;
    /**
     * Checks if this instance expresses a valid {@link Number} value
     * according the
     * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
     *
     * @returns {boolean} Returns true if this instance expresses 32 hex digits (16 bytes, 128 bits) needed to represent
     * a {@link Number} value, else it returns false.
     */
    isNumber(): boolean;
    /**
     * Checks if the given string expression is a valid hexadecimal value.
     *
     * @param {string} exp - The string representation of a hexadecimal value.
     *
     * @return {boolean} - True if the expression is a valid hexadecimal value, case-insensitive,
     * optionally prefixed with `0x`; false otherwise.
     */
    static isValid(exp: string): boolean;
    /**
     * Determines whether the given string is a valid hexadecimal number prefixed with '0x'.
     *
     * @param {string} exp - The string to be evaluated.
     * @return {boolean} - True if the string is a valid hexadecimal number prefixed with '0x', otherwise false.
     */
    static isValid0x(exp: string): boolean;
    /**
     * Create a Hex instance from a bigint, number, string, or Uint8Array.
     *
     * @param {bigint | number | string | Uint8Array} exp - The value to represent in a Hex instance:
     * * bigint is always representable in hexadecimal base notation;
     * * number, encoded as [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format);
     * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
     * * Uint8Array is interpreted as the sequence of bytes.
     *
     * @returns {Hex} - A Hex instance representing the input value.
     *
     * @throws {InvalidDataType} if the given `exp` can't be represented as a hexadecimal expression.
     */
    static of(exp: bigint | number | string | Uint8Array): Hex;
    /**
     * Generates a random Hex value of the given number of bytes length.
     *
     * @param {number} bytes - The number of bytes to generate.
     * @throws {InvalidDataType} - If the bytes argument is not greater than 0.
     * @returns {Hex} - A randomly generated Hex value.
     *
     * @remarks Security auditable method, depends on
     * * [`nh_utils.randomBytes`](https://github.com/paulmillr/noble-hashes?tab=readme-ov-file#utils).
     */
    static random(bytes: number): Hex;
    /**
     * Returns a string representation of the object.
     *
     * @return {string} The string representation of the object.
     */
    toString(): string;
}

/**
 * Represents an ABI (Application Binary Interface).
 * @extends VeChainDataModel
 */
declare class ABI implements VeChainDataModel<ABI> {
    private readonly types;
    private readonly values;
    /**
     * ABI constructor from types and values.
     *
     * @param {string | AbiParameter[]} types - A list of ABI types representing the types of the values.
     * @param {unknown[]} values - An array of values according to the specified ABI types.
     **/
    protected constructor(types?: string | AbiParameter[], values?: unknown[]);
    /**
     * Compares the current ABI instance with another ABI instance.
     * @param that The ABI to compare with.
     * @returns {number} A non-zero number if the current ABI is different to the other ABI or zero if they are equal.
     * @override {@link VeChainDataModel#compareTo}
     * @remark The comparison is done by comparing the types and values of the ABI instances.
     **/
    compareTo(that: ABI): number;
    /**
     * Checks if the current ABI object is equal to the given ABI object.
     * @param that The ABI object to compare with.
     * @returns {boolean} True if the objects are equal, false otherwise.
     * @override {@link VeChainDataModel#isEqual}
     * @remark The comparison is done by comparing the types and values of the ABI instances.
     **/
    isEqual(that: ABI): boolean;
    /**
     * Throws an exception because the ABI cannot be represented as a big integer.
     * @returns {bigint} The BigInt representation of the ABI.
     * @throws {InvalidOperation} The ABI cannot be represented as a bigint.
     * @override {@link VeChainDataModel#bi}
     * @remark The conversion to BigInt is not supported for an ABI.
     */
    get bi(): bigint;
    /**
     * Encodes the values according to the specified ABI types when creating the ABI instance.
     *
     * @returns The ABI-encoded bytes representing the given values.
     * @throws {InvalidAbiDataToEncodeOrDecode, InvalidDataType}
     */
    get bytes(): Uint8Array;
    /**
     * Throws an exception because the ABI cannot be represented as a number.
     * @returns {bigint} The number representation of the ABI.
     * @throws {InvalidOperation} The mnemonic cannot be represented as a number.
     * @override {@link VeChainDataModel#n}
     * @remark The conversion to number is not supported for an ABI.
     */
    get n(): number;
    /**
     * Instantiates an ABI object from the given types and values.
     * @param {string | AbiParameter[]} types ABI parameters representing the types of the values.
     * @param {unknown[]} values ABI values.
     * @returns {ABI} The ABI object with the given types and values.
     */
    static of(types: string | AbiParameter[], values: unknown[]): ABI;
    /**
     * Decodes the ABI values from the given ABI types and encoded data.
     * @param {string| AbiParameter[]} types The list of ABI types representing the types of the values to decode.
     * @param {Hex} dataEncoded The encoded data to decode.
     * @returns An ABI instance with the decoded values.
     */
    static ofEncoded(types: string | AbiParameter[], dataEncoded: string | Uint8Array): ABI;
    /**
     * Recursively parses an object and collects the values of each attribute into an array,
     * with nested arrays for nested objects.
     * @param {object} obj - The object to parse.
     * @returns {unknown[]} An array of values from the object, with nested arrays for nested objects.
     */
    parseObjectValues(obj: object): unknown[];
    /**
     * It gets the first decoded value from the ABI.
     * @returns {ReturnType} The first decoded value from the ABI.
     */
    getFirstDecodedValue<ReturnType>(): ReturnType;
    /**
     * Parses an ABI to its Hex representation.
     * @returns {Hex} The Hex representation of the ABI.
     */
    toHex(): Hex;
}

type SignatureType = string | AbiFunction | AbiEvent;
/**
 * Represents an ABI (Application Binary Interface) item.
 * @extends ABI
 */
declare abstract class ABIItem extends ABI {
    readonly signature: AbiFunction | AbiEvent;
    readonly stringSignature: string;
    /**
     * ABIItem constructor from item (Event, Function...) signature.
     *
     * @param {SignatureType} signature - The signature of the ABI item (Function, Event...).
     **/
    constructor(signature: SignatureType);
    static ofSignature<T extends ABIItem>(ABIItemConstructor: new (signature: string) => T, signature: string): T;
    static ofSignature<T extends ABIItem>(ABIItemConstructor: new (signature: AbiFunction) => T, signature: AbiFunction): T;
    static ofSignature<T extends ABIItem>(ABIItemConstructor: new (signature: AbiEvent) => T, signature: AbiEvent): T;
    /**
     * Returns a string representation of a JSON object or a string.
     * @param {'json' | 'string'} formatType Either JSON or String
     * @returns The string representation of the ABI item.
     */
    format(formatType?: 'json' | 'string'): string;
    /**
     * The signature hash of the ABIItem.
     * @returns {string} The signature hash of the ABIItem.
     * @remarks Wrapper for {@link toFunctionHash}.
     **/
    get signatureHash(): string;
    /**
     * Compares the current ABIItem instance with another ABIItem instance.
     * @param {ABIItem} that The item to compare with.
     * @returns {number} A non-zero number if the current ABIItem is different to the other ABI or zero if they are equal.
     * @override {@link VeChainDataModel#compareTo}
     **/
    compareTo(that: ABIItem): number;
}

interface ABIEventData {
    data: Hex;
    topics: Array<null | Hex | Hex[]>;
}
/**
 * Represents a function call in the Event ABI.
 * @extends ABIItem
 */
declare class ABIEvent<TAbi extends Abi = Abi, TEventName extends ContractEventName<TAbi> = ContractEventName<TAbi>> extends ABIItem {
    private readonly abiEvent;
    constructor(signature: string);
    constructor(signature: AbiEvent);
    /**
     * Decode event log data using the event's ABI.
     *
     * @param abi - Event to decode.
     * @returns Decoding results.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    static parseLog<TAbi extends Abi, TEventName extends ContractEventName<TAbi>>(abi: TAbi, eventData: ABIEventData): DecodeEventLogReturnType<TAbi, TEventName>;
    /**
     * Decode event log data using the event's ABI.
     *
     * @param event - Event to decode.
     * @returns Decoding results.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    decodeEventLog(event: ABIEventData): DecodeEventLogReturnType<TAbi, TEventName>;
    /**
     * Decode event log data as an array of values
     * @param {ABIEvent} event The data to decode.
     * @returns {unknown[]} The decoded data as array of values.
     */
    decodeEventLogAsArray(event: ABIEventData): unknown[];
    /**
     * Encode event log data returning the encoded data and topics.
     * @param dataToEncode - Data to encode.
     * @returns {ABIEventData} Encoded data along with topics.
     * @remarks There is no equivalent to encodeEventLog in viem {@link https://viem.sh/docs/ethers-migration}. Discussion started here {@link https://github.com/wevm/viem/discussions/2676}.
     */
    encodeEventLog(dataToEncode: unknown[]): ABIEventData;
    /**
     * Encode event log topics using the event's ABI.
     *
     * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.
     *                         Only the values of the indexed parameters are needed.
     * @returns Encoded topics array.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    encodeFilterTopics(valuesToEncode: Record<string, unknown> | unknown[] | undefined): EncodeEventTopicsReturnType;
    /**
     * Encode event log topics using the event's ABI, replacing null values with undefined.
     * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.
     *                         Only the values of the indexed parameters are needed.
     * @returns Encoded topics array.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    encodeFilterTopicsNoNull(valuesToEncode: Record<string, unknown> | unknown[] | undefined): Array<string | undefined>;
}

/**
 * Represents a function call in the Function ABI.
 * @extends ABIItem
 */
declare class ABIFunction<TAbi extends Abi = Abi, TFunctionName extends ContractFunctionName<TAbi> = ContractFunctionName<TAbi>> extends ABIItem {
    private readonly abiFunction;
    constructor(signature: string);
    constructor(signature: AbiFunction);
    /**
     * Get the function selector.
     * @returns {string} The function selector.
     * @override {@link ABIItem#signatureHash}
     */
    get signatureHash(): string;
    /**
     * Decode data using the function's ABI.
     *
     * @param {Hex} data - Data to decode.
     * @returns Decoding results.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    decodeData(data: Hex): DecodeFunctionDataReturnType<TAbi, TFunctionName>;
    /**
     * Encode data using the function's ABI.
     *
     * @param dataToEncode - Data to encode.
     * @returns {Hex} Encoded data.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    encodeData<TValue>(dataToEncode?: TValue[]): Hex;
    /**
     * Decodes the output data from a transaction based on ABI (Application Binary Interface) specifications.
     * This method attempts to decode the given hex-like data into a readable format using the contract's interface.
     *
     * @param {Hex} data - The data to be decoded, typically representing the output of a contract function call.
     * @returns {DecodeFunctionResultReturnType} An object containing the decoded data.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     *
     * @example
     * ```typescript
     *   const decoded = abiFunctionInstance.decodeResult(rawTransactionOutput);
     *   console.log('Decoded Output:', decoded);
     * ```
     */
    decodeResult(data: Hex): DecodeFunctionResultReturnType<TAbi, TFunctionName>;
    /**
     * Decodes a function output returning an array of values.
     * @param {Hex} data The data to be decoded
     * @returns {unknown[]} The decoded data as array of values
     */
    decodeOutputAsArray(data: Hex): unknown[];
}

declare class ABIContract<TAbi extends Abi> extends ABI {
    readonly abi: TAbi;
    private readonly viemABI;
    constructor(abi: TAbi);
    /**
     * Creates an ABIContract instance from a viem ABI.
     * @param {ViemABI} abi representation of the contract.
     * @returns New instance of ABIContract.
     */
    static ofAbi<TAbi extends Abi>(abi: TAbi): ABIContract<TAbi>;
    /**
     * Returns the function with the given name.
     * @param {string} name The function's name.
     * @returns {ABIFunction} The function with the given name.
     * @throws {InvalidAbiItem}
     */
    getFunction<TFunctionName extends ContractFunctionName<TAbi>>(name: TFunctionName | string): ABIFunction<TAbi, TFunctionName>;
    /**
     * Returns the event with the given name.
     * @param {string} name The event's name.
     * @returns {ABIEvent} The event with the given name.
     * @throws {InvalidAbiItem}
     */
    getEvent<TEventName extends ContractEventName<TAbi>>(name: TEventName | string): ABIEvent<TAbi, TEventName>;
    /**
     * Encode function data that can be used to send a transaction.
     * @param {string} functionName The name of the function defined in the ABI.
     * @param {unknown[]} functionData The data to pass to the function.
     * @returns {Hex} The encoded data in hexadecimal that can be used to send a transaction.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    encodeFunctionInput<TFunctionName extends ContractFunctionName<TAbi>>(functionName: TFunctionName | string, functionData?: unknown[]): Hex;
    /**
     * Decode the function data of an encoded function
     * @param {string} functionName The name of the function defined in the ABI.
     * @param {Hex} encodedFunctionInput The encoded function data.
     * @returns {DecodeFunctionDataReturnType} an array of the decoded function data
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    decodeFunctionInput<TFunctionName extends ContractFunctionName<TAbi>>(functionName: TFunctionName | string, encodedFunctionInput: Hex): DecodeFunctionDataReturnType<TAbi, TFunctionName>;
    /**
     * Decodes the output from a contract function using the specified ABI and function name.
     * It takes the encoded function output and attempts to decode it according to the ABI definition.
     *
     * @param {string} functionName - The name of the function in the contract to decode the output for.
     * @param {Hex} encodedFunctionOutput - The encoded output data from the contract function.
     * @returns {DecodeFunctionResultReturnType} - The decoded output, which provides a user-friendly way
     * to interact with the decoded data.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     *
     * @example
     * // Example of decoding output for a function called "getValue":
     * const decodedOutput = decodeFunctionOutput('getValue', encodedValue);
     *
     */
    decodeFunctionOutput<TFunctionName extends ContractFunctionName<TAbi>>(functionName: TFunctionName | string, encodedFunctionOutput: Hex): DecodeFunctionResultReturnType<TAbi, TFunctionName>;
    /**
     * Encodes event log data based on the provided event name, and data to encode.
     * @param {string} eventName - The name of the event to be encoded.
     * @param {unknown[]} eventArgs - An array of data to be encoded in the event log.
     * @returns {ABIEventData} An object containing the encoded data and topics.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    encodeEventLog<TEventName extends ContractEventName<TAbi>>(eventName: TEventName | string, eventArgs: unknown[]): ABIEventData;
    /**
     * Decodes event log data based on the provided event name, and data/topics to decode.
     * @param {string} eventName - The name of the event to be decoded.
     * @param {ABIEventData} eventToDecode - An object containing the data and topics to be decoded.
     * @returns {DecodeEventLogReturnType} The decoded data of the event log.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    decodeEventLog<TEventName extends ContractEventName<TAbi>>(eventName: TEventName | string, eventToDecode: ABIEventData): DecodeEventLogReturnType<TAbi, TEventName>;
    /**
     * Decodes a VeChain log based on the ABI definition.
     *
     * This method takes raw `data` and `topics` from a VeChain log and attempts
     * to decode them using the contract's ABI definition. If the decoding is successful,
     * it returns a log object representing the decoded information. If the decoding fails,
     * it throws a custom error with detailed information.
     *
     * @param {Hex} data - The hexadecimal string of the data field in the log.
     * @param {Hex[]} topics - An array of hexadecimal strings representing the topics of the log.
     * @returns {DecodeEventLogReturnType} - A log object representing the decoded log or null if decoding fails.
     * @throws {InvalidAbiDataToEncodeOrDecode}
     */
    parseLog<TEventName extends ContractEventName<TAbi>>(data: Hex, topics: Hex[]): DecodeEventLogReturnType<TAbi, TEventName>;
    /**
     *
     * Parses the log data and topics into an array of values.
     *
     * @param {Hex} data - The hexadecimal string of the data field in the log.
     * @param {Hex[]} topics - An array of hexadecimal strings representing the topics of the log.
     * @returns {unknown[]} - An array of values of the decoded log data.
     */
    parseLogAsArray(data: Hex, topics: Hex[]): unknown[];
}

/**
 * Represents a hexadecimal signed integer value.
 *
 * @remarks This class makes equal instances created from the same value as number or as bigint.
 *
 * @extends {Hex}
 */
declare class HexInt extends Hex {
    /**
     * Retrieves the value of n cast from this instance interpreted as the hexadecimal expression of a bigint value.
     *
     * @return {number} The value of n.
     *
     * @throws {InvalidDataType} If n is not within the safe number range, if the number representation of this
     * instance results approximated.
     *
     * @remarks This class makes equal instances created from the same value as number or as bigint.
     */
    get n(): number;
    /**
     * Create a HexInt instance from a bigint, number, string, Uint8Array, or {@link Hex}.
     *
     * @param {bigint | number | string | Uint8Array | Hex} exp - The expression to be interpreted as an integer:
     * * bigint is always representable in hexadecimal base notation;
     * * number is converted to a bigint then represented in hexadecimal base notation;
     *   it throws {@link InvalidDataType} if not an integer value;
     * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
     * * Uint8Array is interpreted as the sequence of bytes expressing a bigint value;
     * * {@link Hex} is interpreted as expressing a bigint value.
     *
     * @returns {HexInt} - The new HexInt object representing the given `exp`.
     *
     * @throws {InvalidDataType} - If the given `exp` is not a valid hexadecimal integer expression,
     * if `exp` is a not integer number.
     *
     * @remarks This class makes equal instances created from the same value as number or as bigint.
     */
    static of(exp: bigint | number | string | Uint8Array | Hex): HexInt;
}

/**
 * Represents a hexadecimal unsigned integer value.
 *
 * @extends HexInt
 */
declare class HexUInt extends HexInt {
    /**
     * Regular expression for matching hexadecimal strings.
     * An empty input is represented as a empty digits.
     *
     * @type {RegExp}
     */
    private static readonly REGEX_HEXUINT;
    /**
     * Regular expression pattern to match a prefix indicating hexadecimal number.
     *
     * @type {RegExp}
     */
    protected static readonly REGEX_HEXUINT_PREFIX: RegExp;
    /**
     * Checks if the given string expression is a valid unsigned hexadecimal value.
     *
     * @param {string} exp - The string representation of a hexadecimal value.
     *
     * @return {boolean} - True if the expression is a valid unsigned hexadecimal value, case-insensitive,
     * optionally prefixed with `0x`; false otherwise.
     */
    static isValid(exp: string): boolean;
    /**
     * Determines whether the given string is a valid unsigned hexadecimal number prefixed with '0x'.
     *
     * @param {string} exp - The string to be evaluated.
     * @return {boolean} - True if the string is a valid unsigned hexadecimal number prefixed with '0x', otherwise false.
     */
    static isValid0x(exp: string): boolean;
    /**
     * Create a HexUInt instance from a bigint, number, string, Uint8Array, or {@link HexInt}.
     *
     * @param {bigint | number | string | Uint8Array | HexInt} exp - The expression to be interpreted as an unsigned integer:
     * * bigint is always representable in hexadecimal base notation,
     *   it throws {@link InvalidDataType} if not positive;
     * * number is converted to a bigint then represented in hexadecimal base notation,
     *   it throws {@link InvalidDataType} if not a positive integer value;
     * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;
     *   it throws {@link InvalidDataType} if not positive;
     * * Uint8Array is interpreted as the sequence of bytes expressing a positive bigint value;
     * * {@link HexInt} is interpreted as expressing a bigint value,
     *   it throws {@link InvalidDataType} if not positive.
     *
     * @returns {HexUInt} he new HexInt object representing the given `exp`.
     *
     * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.
     */
    static of(exp: bigint | number | string | Uint8Array | HexInt): HexUInt;
}

/**
 * Represents a VeChain Address as unsigned integer.
 *
 * @extends {HexUInt}
 */
declare class Address extends HexUInt {
    /**
     * The address is 20 bytes hence 40 digits long.
     */
    static readonly DIGITS: number;
    /**
     * It checksums a given hexadecimal address.
     *
     * @param {HexUInt} huint - The HexUInt object representing the hexadecimal value.
     *
     * @returns {string} The checksummed address.
     */
    static checksum(huint: HexUInt): string;
    /**
     * Validate the given expression to be a valid address.
     *
     *  @param {string} exp - Expression to validate
     *
     * @returns {boolean} true if the expression is a valid address, false otherwise
     */
    static isValid(exp: string): boolean;
    /**
     * Create an Address instance from the given expression interpreted as an unsigned integer.
     *
     * @param exp - The expression to convert.
     * It can be of type bigint, number, string, Uint8Array, or HexUInt.
     * Not meaningful `0` digits on the left of the expression can be omitted,
     * the returned address is always 20 bytes, 40 digits expression.
     *
     * @returns {Address} The converted hexadecimal unsigned integer.
     *
     * @throws {InvalidDataType} If the expression is not a valid hexadecimal positive integer expression.
     */
    static of(exp: bigint | number | string | Uint8Array | HexUInt): Address;
    /**
     * Create an Address instance from the given private key.
     *
     * @param {Uint8Array} privateKey - The private key to convert.
     *
     * @param {boolean} [isCompressed=true] - The flag to indicate if the derived public key should be compressed.
     *
     * @returns {Address} The converted address.
     *
     * @remarks Security auditable method, depends on
     * * {@link Secp256k1.derivePublicKey}.
     */
    static ofPrivateKey(privateKey: Uint8Array, isCompressed?: boolean): Address;
    /**
     * Create an Address instance from the given public key.
     *
     * @param {Uint8Array} publicKey - The public key to convert.
     *
     * @returns {Address} The converted address.
     *
     * @remarks Security auditable method, depends on
     * * {@link Secp256k1.inflatePublicKey}.
     */
    static ofPublicKey(publicKey: Uint8Array): Address;
    /**
     * Derives the address from a given list of words of
     * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
     * and a [BIP44 Derivation Path](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
     * as in the examples.
     *
     * Secure audit function.
     * - {@link bip32.HDKey}(https://github.com/paulmillr/scure-bip32)
     * - {@link HDKey}
     *
     * @example `m/0` (default)
     * @example `m/0/2`
     * @example `m/0/2/4/6`
     *
     * @param {string[]} mnemonic - Mnemonic used to generate the HD node.
     * @param {string} [path='m/0'] - The derivation path from the current node.
     * @return {Address} - The derived address.
     * @throws {InvalidHDKey}
     *
     */
    static ofMnemonic(mnemonic: string[], path?: string): Address;
}

/**
 * Represents a fixed-point number for precision arithmetic.
 */
declare class FixedPointNumber implements VeChainDataModel<FixedPointNumber> {
    /**
     * Base of value notation.
     */
    private static readonly BASE;
    /**
     * The default number of decimal places to use for fixed-point math.
     *
     * @see
     * [bignumber.js DECIMAL_PLACES](https://mikemcl.github.io/bignumber.js/#decimal-places)
     *
     * @constant {bigint}
     */
    protected static readonly DEFAULT_FRACTIONAL_DECIMALS = 20n;
    /**
     * Not a Number.
     *
     * @remarks {@link fractionalDigits} and {@link scaledValue} not meaningful.
     *
     * @see [Number.NaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN)
     *
     */
    static readonly NaN: FixedPointNumber;
    /**
     * The negative Infinity value.
     *
     * @remarks {@link fractionalDigits} and {@link scaledValue} not meaningful.
     *
     * @see [Number.NEGATIVE_INFINITY](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY)
     */
    static readonly NEGATIVE_INFINITY: FixedPointNumber;
    /**
     * Represents the one constant.
     */
    static readonly ONE: FixedPointNumber;
    /**
     * The positive Infinite value.
     *
     * @remarks {@link fractionalDigits} and {@link scaledValue} not meaningful.
     *
     * @see [Number.POSITIVE_INFINITY](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY)
     */
    static readonly POSITIVE_INFINITY: FixedPointNumber;
    /**
     * Regular expression pattern for matching integers expressed as base 10 strings.
     */
    private static readonly REGEX_INTEGER;
    /**
     * Regular expression for matching numeric values expressed as base 10 strings.
     */
    private static readonly REGEX_NUMBER;
    /**
     * Regular expression pattern for matching natural numbers expressed as base 10 strings.
     */
    private static readonly REGEX_NATURAL;
    /**
     * Represents the zero constant.
     */
    static readonly ZERO: FixedPointNumber;
    /**
     * Edge Flag denotes the {@link NaN} or {@link NEGATIVE_INFINITY} or {@link POSITIVE_INFINITY} value.
     *
     * @remarks If `ef` is not zero, {@link fractionalDigits} and {@link scaledValue} are not meaningful.
     */
    protected readonly edgeFlag: number;
    /**
     * Fractional Digits or decimal places.
     *
     * @see [bignumber.js precision](https://mikemcl.github.io/bignumber.js/#sd)
     */
    readonly fractionalDigits: bigint;
    /**
     * Scaled Value = value * 10 ^ {@link fractionalDigits}.
     */
    readonly scaledValue: bigint;
    /**
     * Returns the integer part of this FixedPointNumber value.
     *
     * @return {bigint} the integer part of this FixedPointNumber value.
     *
     * @throws {InvalidOperation} If the value is not finite.
     */
    get bi(): bigint;
    /**
     * Returns the array of bytes representing the *Normalization Form Canonical Composition*
     * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)
     * of this value expressed in decimal base.
     */
    get bytes(): Uint8Array;
    /**
     * Return this value approximated as {@link number}.
     */
    get n(): number;
    /**
     * Returns the new Fixed-Point Number (FixedPointNumber) instance having
     *
     * @param {bigint} fd - Number of Fractional Digits (or decimal places).
     * @param {bigint} sv - Scaled Value.
     * @param {number} [ef=0] - Edge Flag.
     */
    protected constructor(fd: bigint, sv: bigint, ef?: number);
    /**
     * Returns a FixedPointNumber whose value is the absolute value, i.e. the magnitude, of the value of this FixedPointNumber.
     *
     * @return {FixedPointNumber} the absolute value of this FixedPointNumber.
     *
     * @see [bignumber.js absoluteValue](https://mikemcl.github.io/bignumber.js/#abs)
     */
    abs(): FixedPointNumber;
    /**
     * Compares this instance with `that` FixedPointNumber instance.
     * * Returns 0 if this is equal to `that` FixedPointNumber, including infinite with equal sign;
     * * Returns -1, if this is -Infinite or less than `that` FixedPointNumber;,
     * * Returns 1 if this is +Infinite or greater than `that` FixedPointNumber.
     *
     * @param {FixedPointNumber} that - The instance to compare with this instance.
     * @return {number} Returns -1, 0, or 1 if this instance is less than, equal to, or greater
     * than the specified instance, respectively.
     * @throw InvalidOperation If this or `that` FixedPointNumber is {@link NaN}.
     *
     * @see [bignumber.js comparedTo](https://mikemcl.github.io/bignumber.js/#cmp)
     */
    compareTo(that: FixedPointNumber): number;
    /**
     * Compares this instance with `that` FixedPointNumber instance.
     * * **Returns `null` if either instance is NaN;**
     * * Returns 0 if this is equal to `that` FixedPointNumber, including infinite with equal sign;
     * * Returns -1, if this is -Infinite or less than `that` FixedPointNumber;,
     * * Returns 1 if this is +Infinite or greater than `that` FixedPointNumber.
     *
     * @param {FixedPointNumber} that - The instance to compare with this instance.
     * @return {null | number} A null if either instance is NaN;
     * -1, 0, or 1 if this instance is less than, equal to, or greater
     * than the specified instance, respectively.
     *
     * @remarks This method uses internally {@link compareTo} wrapping the {@link InvalidOperation} exception
     * when comparing between {@link NaN} values to behave according the
     * [[bignumber.js comparedTo](https://mikemcl.github.io/bignumber.js/#cmp)] rules.
     */
    comparedTo(that: FixedPointNumber): null | number;
    /**
     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber divided by `that` FixedPointNumber.
     *
     * Limit cases
     * * 0 / 0 = NaN
     * * NaN / ±n = NaN
     * * ±Infinity / ±Infinity = NaN
     * * +n / NaN = NaN
     * * +n / ±Infinity = 0
     * * -n / 0 = -Infinity
     * * +n / 0 = +Infinity
     *
     * @param {FixedPointNumber} that - The fixed-point number to divide by.
     * @return {FixedPointNumber} The result of the division.
     *
     * @remarks The precision is the greater of the precision of the two operands.
     *
     * @see [bignumber.js dividedBy](https://mikemcl.github.io/bignumber.js/#div)
     */
    div(that: FixedPointNumber): FixedPointNumber;
    /**
     * Divides the given dividend by the given divisor, adjusted by a factor based on fd.
     *
     * @param {bigint} fd - The factor determining the power of 10 to apply to the dividend.
     * @param {bigint} dividend - The number to be divided.
     * @param {bigint} divisor - The number by which to divide the dividend.
     *
     * @return {bigint} - The result of the division, adjusted by the given factor fd.
     */
    private static div;
    /**
     * Adjust the precision of the floating-point number by the specified
     * number of decimal places.
     *
     * @param decimalPlaces The number of decimal places to adjust to,
     *                      it must be a positive value.
     * @return {FixedPointNumber} A new FixedPointNumber instance with the adjusted precision.
     * @throws InvalidDataType if `decimalPlaces` is negative.
     */
    dp(decimalPlaces: bigint | number): FixedPointNumber;
    /**
     * Returns `true `if the value of thisFPN is equal to the value of `that` FixedPointNumber, otherwise returns `false`.
     *
     * As with JavaScript, `NaN` does not equal `NaN`.
     *
     * @param {FixedPointNumber} that - The FixedPointNumber to compare against.
     * @return {boolean} `true` if the FixedPointNumber numbers are equal, otherwise `false`.
     *
     * @remarks This method uses {@link comparedTo} internally.
     *
     * @see [bigbumber.js isEqualTo](https://mikemcl.github.io/bignumber.js/#eq)
     */
    eq(that: FixedPointNumber): boolean;
    /**
     * Returns `true` if the value of this FixedPointNumber is greater than `that` FixedPointNumber`, otherwise returns `false`.
     *
     * @param {FixedPointNumber} that The FixedPointNumber to compare against.
     * @return {boolean} `true` if this FixedPointNumber is greater than `that` FixedPointNumber, otherwise `false`.
     *
     * @remarks This method uses {@link comparedTo} internally.
     *
     * @see [bignummber.js isGreaterThan](https://mikemcl.github.io/bignumber.js/#gt)
     */
    gt(that: FixedPointNumber): boolean;
    /**
     * Returns `true` if the value of this FixedPointNumber is greater or equal than `that` FixedPointNumber`, otherwise returns `false`.
     *
     * @param {FixedPointNumber} that - The FixedPointNumber to compare against.
     * @return {boolean} `true` if this FixedPointNumber is greater or equal than `that` FixedPointNumber, otherwise `false`.
     *
     * @remarks This method uses {@link comparedTo} internally.
     *
     * @see [bignumber.js isGreaterThanOrEqualTo](https://mikemcl.github.io/bignumber.js/#gte)
     */
    gte(that: FixedPointNumber): boolean;
    /**
     * Returns a fixed-point number whose value is the integer part of dividing the value of this fixed-point number
     * by `that` fixed point number.
     *
     * Limit cases
     * * 0 / 0 = NaN
     * * NaN / ±n = NaN
     * * ±Infinity / ±Infinity = NaN
     * * +n / NaN = NaN
     * * +n / ±Infinite = 0
     * * -n / 0 = -Infinite
     * * +n / 0 = +Infinite
     *
     * @param {FixedPointNumber} that - The fixed-point number to divide by.
     * @return {FixedPointNumber} The result of the division.
     *
     * @remarks The precision is the greater of the precision of the two operands.
     *
     * @see [bignumber.js dividedToIntegerBy](https://mikemcl.github.io/bignumber.js/#divInt)
     */
    idiv(that: FixedPointNumber): FixedPointNumber;
    /**
     * Performs integer division on two big integers and scales the result by a factor of 10 raised to the power of fd.
     *
     * @param {bigint} fd - The power to which 10 is raised to scale the result.
     * @param {bigint} dividend - The number to be divided.
     * @param {bigint} divisor - The number by which dividend is divided.
     * @return {bigint} - The scaled result of the integer division.
     */
    private static idiv;
    /**
     * Returns `true `if the value of thisFPN is equal to the value of `that` FixedPointNumber, otherwise returns `false`.
     *
     * As with JavaScript, `NaN` does not equal `NaN`.
     *
     * @param {FixedPointNumber} that - The FixedPointNumber to compare against.
     * @return {boolean} `true` if the FixedPointNumber numbers are equal, otherwise `false`.
     *
     * @remarks This method uses {@link eq} internally.
     */
    isEqual(that: FixedPointNumber): boolean;
    /**
     * Returns `true` if the value of this FixedPointNumber is a finite number, otherwise returns `false`.
     *
     * The only possible non-finite values of a FixedPointNumber are {@link NaN}, {@link NEGATIVE_INFINITY} and {@link POSITIVE_INFINITY}.
     *
     * @return `true` if the value of this FixedPointNumber is a finite number, otherwise returns `false`.
     *
     * @see [bignumber.js isFinite](https://mikemcl.github.io/bignumber.js/#isF)
     */
    isFinite(): boolean;
    /**
     * Return `true` if the value of this FixedPointNumber is {@link NEGATIVE_INFINITY} or {@link POSITIVE_INFINITY},
     * otherwise returns false.
     *
     * @return true` if the value of this FixedPointNumber is {@link NEGATIVE_INFINITY} or {@link POSITIVE_INFINITY},
     */
    isInfinite(): boolean;
    /**
     * Returns `true` if the value of this FixedPointNumber is an integer,
     * otherwise returns `false`.
     *
     * @return `true` if the value of this FixedPointNumber is an integer.
     *
     * @see [bignumber.js isInteger](https://mikemcl.github.io/bignumber.js/#isInt)
     */
    isInteger(): boolean;
    /**
     * Checks if a given string expression is an integer in base 10 notation,
     * considering `-` for negative and `+` optional for positive values.
     *
     * @param {string} exp - The string expression to be tested.
     *
     * @return {boolean} `true` if the expression is an integer,
     * `false` otherwise.
     */
    static isIntegerExpression(exp: string): boolean;
    /**
     *  Returns `true` if the value of this FixedPointNumber is `NaN`, otherwise returns `false`.
     *
     *  @return `true` if the value of this FixedPointNumber is `NaN`, otherwise returns `false`.
     *
     *  @see [bignumber.js isNaN](https://mikemcl.github.io/bignumber.js/#isNaN)
     */
    isNaN(): boolean;
    /**
     * Checks if a given string expression is a natural (unsigned positive integer)
     * number in base 10 notation.
     *
     * @param {string} exp - The string expression to be tested.
     *
     * @return {boolean} `true` if the expression is a natural number,
     * `false` otherwise.
     */
    static isNaturalExpression(exp: string): boolean;
    /**
     * Returns `true` if the sign of this FixedPointNumber is negative, otherwise returns `false`.
     *
     * @return `true` if the sign of this FixedPointNumber is negative, otherwise returns `false`.
     *
     * @see [bignumber.js isNegative](https://mikemcl.github.io/bignumber.js/#isNeg)
     */
    isNegative(): boolean;
    /**
     * Returns `true` if this FixedPointNumber value is {@link NEGATIVE_INFINITY}, otherwise returns `false`.
     */
    isNegativeInfinite(): boolean;
    /**
     * Checks if a given string expression is a number in base 10 notation,
     * considering `-` for negative and `+` optional for positive values.
     *
     * The method returns `true` for the following cases.
     * - Whole numbers:
     *   - Positive whole numbers, optionally signed: 1, +2, 3, ...
     *   - Negative whole numbers: -1, -2, -3, ...
     * - Decimal numbers:
     *   - Positive decimal numbers, optionally signed: 1.0, +2.5, 3.14, ...
     *   - Negative decimal numbers: -1.0, -2.5, -3.14, ...
     *   - Decimal numbers without whole part:
     *     - Positive decimal numbers, optionally signed: .1, +.5, .75, ...
     *     - Negative decimal numbers: -.1, -.5, -.75, ...
     *
     * @param exp - The string expression to be checked.
     *
     * @return `true` is `exp` represents a number, otherwise `false`.
     */
    static isNumberExpression(exp: string): boolean;
    /**
     * Returns `true` if the sign of this FixedPointNumber is positive, otherwise returns `false`.
     *
     * @return `true` if the sign of this FixedPointNumber is positive, otherwise returns `false`.
     *
     * @see [bignumber.js isPositive](https://mikemcl.github.io/bignumber.js/#isPos)
     */
    isPositive(): boolean;
    /**
     * Returns `true` if this FixedPointNumber value is {@link POSITIVE_INFINITY}, otherwise returns `false`.
     *
     * @return `true` if this FixedPointNumber value is {@link POSITIVE_INFINITY}, otherwise returns `false`.
     */
    isPositiveInfinite(): boolean;
    /**
     * Returns `true` if the value of this FixedPointNumber is zero or minus zero, otherwise returns `false`.
     *
     * @return `true` if the value of this FixedPointNumber is zero or minus zero, otherwise returns `false`.
     *
     * [see bignumber.js isZero](https://mikemcl.github.io/bignumber.js/#isZ)
     */
    isZero(): boolean;
    /**
     * Returns `true` if the value of this FixedPointNumber is less than the value of `that` FixedPointNumber, otherwise returns `false`.
     *
     * @param {FixedPointNumber} that - The FixedPointNumber to compare against.
     *
     * @return {boolean} `true` if the value of this FixedPointNumber is less than the value of `that` FixedPointNumber, otherwise returns `false`.
     *
     * @remarks This method uses {@link comparedTo} internally.
     *
     * @see [bignumber.js isLessThan](https://mikemcl.github.io/bignumber.js/#lt)
     */
    lt(that: FixedPointNumber): boolean;
    /**
     * Returns `true` if the value of this FixedPointNumber is less than or equal to the value of `that` FixedPointNumber,
     * otherwise returns `false`.
     *
     * @param {FixedPointNumber} that - The FixedPointNumber to compare against.
     * @return {boolean} `true` if the value of this FixedPointNumber is less than or equal to the value of `that` FixedPointNumber,
     * otherwise returns `false`.
     *
     * @remarks This method uses {@link comparedTo} internally.
     *
     * @see [bignumber.js isLessThanOrEqualTo](https://mikemcl.github.io/bignumber.js/#lte)
     */
    lte(that: FixedPointNumber): boolean;
    /**
     * Return the maximum between the fixed decimal value of this object and `that` one.
     * If the maximum fixed digits value is less than `minFixedDigits`, return `minFixedDigits`.
     *
     * @param {FixedPointNumber} that to evaluate if `that` has the maximum fixed digits value.
     * @param {bigint} minFixedDigits Min value of returned value, {@link FixedPointNumber.DEFAULT_FRACTIONAL_DECIMALS} by default.
     *
     * @return the greater fixed digits value among `this`, `that` and `minFixedDigits`.
     */
    private maxFractionalDigits;
    /**
     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber minus `that` FixedPointNumber.
     *
     * Limit cases
     * * NaN - ±n = NaN
     * * ±n - NaN = NaN
     * * -Infinity - -Infinity = NaN
     * * -Infinity - +n = -Infinity
     * * +Infinity - +Infinity = NaN
     * * +Infinity - +n = +Infinity
     *
     * @param {FixedPointNumber} that - The fixed-point number to subtract.
     * @return {FixedPointNumber} The result of the subtraction. The return value is always exact and unrounded.
     *
     * @remarks The precision is the greater of the precision of the two operands.
     *
     * @see [bignumber.js minus](https://mikemcl.github.io/bignumber.js/#minus)
     */
    minus(that: FixedPointNumber): FixedPointNumber;
    /**
     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber modulo `that` FixedPointNumber,
     * i.e. the integer remainder of dividing this FixedPointNumber by `that`.
     *
     * Limit cases
     * * NaN % ±n = NaN
     * * ±n % NaN = NaN
     * * ±Infinity % n = NaN
     * * n % ±Infinity = NaN
     *
     * @param that {FixedPointNumber} - The fixed-point number to divide by.
     * @return {FixedPointNumber} the integer remainder of dividing this FixedPointNumber by `that`.
     *
     * @remarks The precision is the greater of the precision of the two operands.
     *
     * @see [bignumber.js modulo](https://mikemcl.github.io/bignumber.js/#mod)
     */
    modulo(that: FixedPointNumber): FixedPointNumber;
    /**
     * Multiplies two big integer values and divides by a factor of ten raised to a specified power.
     *
     * @param {bigint} multiplicand - The first number to be multiplied.
     * @param {bigint} multiplicator - The second number to be multiplied.
     * @param {bigint} fd - The power of ten by which the product is to be divided.
     *
     * @return {bigint} The result of the multiplication divided by ten raised to the specified power.
     */
    private static mul;
    /**
     * Returns a new instance of FixedPointNumber whose value is the value of this FixedPointNumber value
     * negated, i.e. multiplied by -1.
     *
     * @see [bignumber.js negated](https://mikemcl.github.io/bignumber.js/#neg)
     */
    negated(): FixedPointNumber;
    /**
     * Constructs a new instance of FixedPointNumber (Fixed Point Number) parsing the
     * `exp` numeric expression in base 10 and representing the value with the
     * precision of `decimalPlaces` fractional decimal digits.
     *
     * @param {bigint|number|string} exp - The value to represent.
     * It can be a bigint, number, or string representation of the number.
     * @param {bigint} [decimalPlaces=this.DEFAULT_FRACTIONAL_DECIMALS] - The
     * number of fractional decimal digits to be used to represent the value.
     *
     * @return {FixedPointNumber} A new instance of FixedPointNumber with the given parameters.
     *
     * @throws {InvalidDataType} If `exp` is not a numeric expression.
     */
    static of(exp: bigint | number | string | FixedPointNumber, decimalPlaces?: bigint): FixedPointNumber;
    /**
     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber plus `that` FixedPointNumber.
     *
     * Limit cases
     * * NaN + ±n = NaN
     * * ±n + NaN = NaN
     * * -Infinity + -Infinity = -Infinity
     * * -Infinity + +Infinity = NaN
     * * +Infinity + -Infinity = NaN
     * * +Infinity + +Infinity = +Infinity
     *
     * @param {FixedPointNumber} that - The fixed-point number to add to the current number.
     * @return {FixedPointNumber} The result of the addition. The return value is always exact and unrounded.
     *
     * @remarks The precision is the greater of the precision of the two operands.
     *
     * @see [bignumber.js plus](https://mikemcl.github.io/bignumber.js/#plus)
     */
    plus(that: FixedPointNumber): FixedPointNumber;
    /**
     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber raised to the power of `that` FixedPointNumber.
     *
     * This method implements the
     * [Exponentiation by Squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring)
     * algorithm.
     *
     * Limit cases
     * * NaN ^ e = NaN
     * * b ^ NaN = NaN
     * * b ^ -Infinite = 0
     * * b ^ 0 = 1
     * * b ^ +Infinite = +Infinite
     * * ±Infinite ^ -e = 0
     * * ±Infinite ^ +e = +Infinite
     *
     * @param {FixedPointNumber} that - The exponent as a fixed-point number.
     * truncated to its integer component because **Exponentiation by Squaring** is not valid for rational exponents.
     * @return {FixedPointNumber} - The result of raising this fixed-point number to the power of the given exponent.
     *
     * @see [bignumber.js exponentiatedBy](https://mikemcl.github.io/bignumber.js/#pow)
     */
    pow(that: FixedPointNumber): FixedPointNumber;
    /**
     * Computes the square root of a given positive bigint value using a fixed-point iteration method.
     *
     * @param {bigint} value - The positive bigint value for which the square root is to be calculated.
     * @param {bigint} fd - The iteration factor determinant.
     * @return {bigint} The calculated square root of the input bigint value.
     *
     * @throws {RangeError} If the input value is negative.
     */
    private static sqr;
    /**
     * Returns a FixedPointNumber whose value is the square root of the value of this FixedPointNumber
     *
     * Limit cases
     * * NaN = NaN
     * * +Infinite = +Infinite
     * * -n = NaN
     *
     * @return {FixedPointNumber} The square root of the number.
     *
     * @see [bignumber.js sqrt](https://mikemcl.github.io/bignumber.js/#sqrt)
     */
    sqrt(): FixedPointNumber;
    /**
     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber multiplied by `that` FixedPointNumber.
     *
     * Limits cases
     * * NaN * n = NaN
     * * n * NaN = NaN
     * * -Infinite * -n = +Infinite
     * * -Infinite * +n = -Infinite
     * * +Infinite * -n = -Infinite
     * * +Infinite * +n = +Infinite
     *
     * @param {FixedPointNumber} that - The fixed-point number to multiply with this number.
     * @return {FixedPointNumber} a FixedPointNumber whose value is the value of this FixedPointNumber multiplied by `that` FixedPointNumber.
     *
     * @remarks The precision is the greater of the precision of the two operands.
     *
     * @see [bignumber.js multipliedBy](https://mikemcl.github.io/bignumber.js/#times)
     */
    times(that: FixedPointNumber): FixedPointNumber;
    /**
     * Converts the fixed-point number to its string representation.
     *
     * @param {string} [decimalSeparator='.'] - The character to use as the decimal separator in the string representation. Default is '.'.
     * @return {string} A string representation of the fixed-point number.
     */
    toString(decimalSeparator?: string): string;
    /**
     * Trims the specified trailing substring from the end of the input string recursively.
     *
     * @param {string} str - The input string to be trimmed.
     * @param {string} [sub='0'] - The substring to be removed from the end of the input string. Defaults to '0' if not provided.
     * @return {string} The trimmed string with the specified trailing substring removed.
     */
    private static trimEnd;
    /**
     * Converts a string expression of a number into a scaled value.
     *
     * @param {string} exp - The string expression of the number to be converted.
     * @param {bigint} fd - The scale factor to be used for conversion.
     * @param {string} [decimalSeparator='.'] - The character used as the decimal separator in the string expression.
     * @return {bigint} - The converted scaled value as a bigint.
     */
    private static txtToSV;
}

/**
 * Represents a text string encoded according the *Normalization Form Canonical Composition*
 * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence).
 *
 * @implements {VeChainDataModel<Txt>}
 */
declare class Txt extends String implements VeChainDataModel<Txt> {
    /**
     * Decoder object used for decoding bytes as text data.
     *
     * @class
     * @constructor
     */
    private static readonly DECODER;
    /**
     * *Normalization Form Canonical Composition*
     * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)
     * flag.
     *
     * @type {string}
     * @constant
     */
    private static readonly NFC;
    /**
     * A TextEncoder instance used for encoding text to bytes.
     *
     * @type {TextEncoder}
     */
    private static readonly ENCODER;
    /**
     * Creates a new instance of this class representing the `exp` string
     * normalized according the *Canonical Composition Form*
     * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence).
     *
     * @param {string} exp - The expression to be passed to the constructor.
     * @protected
     * @constructor
     */
    protected constructor(exp: string);
    /**
     * Converts the current Txt string to a BigInt.
     *
     * @returns {bigint} The BigInt representation of the Txt string.
     *
     *  @throws {InvalidOperation} If the conversion to BigInt fails because this Txt string doesn't represent an integer.
     */
    get bi(): bigint;
    /**
     * Converts the current Txt string to a buffer of bytes.
     *
     * @returns {Uint8Array} The bytes representation of the Txt string.
     */
    get bytes(): Uint8Array;
    /**
     * Returns the value of n as a number.
     *
     * @returns {number} The value of n as a number.
     */
    /**
     * Converts the current Txt string to a number.
     *
     * @returns {number} The numeric value of the Txt string.
     *
     * @throws {InvalidOperation} If the conversion to number fails because this Txt string doesn't represent a decimal number.
     */
    get n(): number;
    /**
     * Compares the current instance to another instance of Txt.
     *
     * @param {Txt} that - The instance to compare with.
     *
     * @return {number} - A negative number if the current instance is less than the specified instance,
     *                    zero if they are equal, or a positive number if the current instance is greater.
     */
    compareTo(that: Txt): number;
    /**
     * Checks if the current Txt object is equal to the given Txt object.
     *
     * @param {Txt} that - The Txt object to compare with.
     *
     *  @return {boolean} - True if the objects are equal, false otherwise.
     */
    isEqual(that: Txt): boolean;
    /**
     * Returns a string representation of the object.
     *
     * @returns {string} A string representation of the object.
     */
    toString(): string;
    /**
     * Creates a new Txt instance from the provided expression.
     *
     * @param {bigint | number | string | Uint8Array} exp - The expression to convert to Txt:
     * * {@link bigint} is represented as a {@link NFC} encoded string expressing the value in base 10;
     * * {@link number} is represented as a {@link NFC} encoded string expressing the value in base 10;
     * * {@link string} is encoded as {@link NFC} string;
     * * {@link Uint8Array} is {@link NFC} decoded to a string.
     *
     * @returns {Txt} - A new Txt instance.
     */
    static of(exp: bigint | number | string | Uint8Array): Txt;
}

/**
 * Interface representing the properties for currency implementation
 * that extends from VeChainDataModel.
 *
 * @interface Currency
 * @extends {VeChainDataModel<Currency>}
 */
interface Currency extends VeChainDataModel<Currency> {
    /**
     * Return the code as a Txt object.
     *
     * @return {Txt} The code object
     *
     * @remarks Since currency codes likely use Unicode composite symbols,
     * {@link Txt} type enforce the reresentation of the code is normalized.
     */
    get code(): Txt;

    /**
     * Return the current value as an FixedPointNumber (Fixed-Point Number).
     *
     * @return {FixedPointNumber} The current value in Fixed-Point Number format.
     */
    get value(): FixedPointNumber;
}

type AccountType = 'EOA' | 'Contract';
/**
 * Represents a VeChain account.
 *
 * @implements {VeChainDataModel<Account>}
 */
declare class Account implements VeChainDataModel<Account> {
    readonly address: Address;
    readonly balance: Currency;
    readonly transactions: string[];
    readonly type: AccountType;
    constructor(address: Address, balance: Currency, type?: AccountType, transactions?: string[]);
    /**
     * Throws an exception because the account cannot be represented as a big integer.
     * @returns {bigint} The BigInt representation of the account.
     * @throws {InvalidOperation} The account cannot be represented as a bigint.
     * @override {@link VeChainDataModel#bi}
     * @remarks The conversion to BigInt is not supported for an account.
     */
    get bi(): bigint;
    /**
     * Throws an exception because the account cannot be represented as a byte array.
     * @returns {Uint8Array} The byte array representation of the account.
     * @throws {InvalidOperation} The account cannot be represented as a byte array.
     * @override {@link VeChainDataModel#bytes}
     * @remarks The conversion to byte array is not supported for an account.
     */
    get bytes(): Uint8Array;
    /**
     * Throws an exception because the account cannot be represented as a number.
     * @returns {bigint} The number representation of the account.
     * @throws {InvalidOperation} The account cannot be represented as a number.
     * @override {@link VeChainDataModel#n}
     * @remarks The conversion to number is not supported for an account.
     */
    get n(): number;
    /**
     * Adds a transaction to the account.
     * @param {string} transaction The transaction to add.
     */
    addTransaction(transaction: string): void;
    /**
     * Compare this instance with `that` in a meaningful way.
     *
     * @param {Account} that object to compare.
     * @return a negative number if `this` < `that`, zero if `this` = `that`, a positive number if `this` > that`.
     * @override {@link VeChainDataModel#compareTo}
     */
    compareTo(that: Account): number;
    /**
     * Checks if the given value is equal to the current instance.
     *
     * @param {Account} that - The value to compare.
     * @returns {boolean} - True if the values are equal, false otherwise.
     * @override {@link VeChainDataModel#isEqual}
     */
    isEqual(that: Account): boolean;
    /**
     * Returns a string representation of the account.
     *
     * @returns {string} A string representation of the account.
     */
    toString(): string;
}

/**
 * The BlockRef class represents a Thor block ID value, which is a hexadecimal positive integer having 64 digits.
 *
 * @extends HexInt
 */
declare class BlockRef extends HexUInt {
    /**
     * Number of digits to represent a block reference value.
     *
     * @remarks The `0x` prefix is excluded.
     *
     * @type {number}
     */
    private static readonly DIGITS;
    /**
     * Constructs a BlockRef object with the provided hexadecimal value.
     *
     * @param {HexUInt} huint - The hexadecimal value representing the BlockId.
     */
    protected constructor(huint: HexUInt);
    /**
     * Check if the given expression is a valid BlockRef.
     *
     * @param {string} exp - The expression to be validated.
     *
     * @return {boolean} Returns true if the expression is a valid BlockRef, false otherwise.
     */
    static isValid(exp: string): boolean;
    /**
     * Determines whether the given string is a valid hex number prefixed with '0x'.
     *
     * @param {string} exp - The hex number to be checked.
     *
     *  @returns {boolean} - True if the hex number is valid, false otherwise.
     */
    static isValid0x(exp: string): boolean;
    /**
     * Creates a new BlockRef object from the given expression.
     *
     * @param {bigint | number | string | Hex | Uint8Array} exp - The expression to create the BlockRef from.
     *     It can be one of the following types:
     *     - bigint: A BigInteger value that represents the BlockRef.
     *     - number: A number value that represents the BlockRef.
     *     - string: A string value that represents the BlockRef.
     *     - HexUInt: A HexUInt object that represents the BlockRef.
     *     - Uint8Array: A Uint8Array object that represents the BlockRef.
     *
     * @returns {BlockRef} - A new BlockRef object created from the given expression.
     *
     * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.
     */
    static of(exp: bigint | number | string | Uint8Array | HexUInt): BlockRef;
}

/**
 * A [Bloom Filter](https://en.wikipedia.org/wiki/Bloom_filter)
 * is a space-efficient probabilistic data structure
 * that is used to test whether an element is a member of a set.
 *
 * @remarks False positive matches are possible, but false negatives are not.
 *
 * @implements {VeChainDataModel<Hex>}
 */
declare class BloomFilter implements VeChainDataModel<BloomFilter> {
    /**
     * Return the Bloom filter structure: an array of `m` bits per key encoding if a key is not part of the structure.
     *
     * @typedef {Uint8Array} bytes
     */
    readonly bytes: Uint8Array;
    /**
     * Return the number of hash functions used to compute this Bloom filter.
     *
     * @type {number}
     */
    readonly k: number;
    /**
     * Creates a new instance of this class.
     *
     * @param {Uint8Array} bytes - The Bloom filter structure of `m` bits per key encoding if the key
     *                             likely belongs to the structure or surely doesn't.
     * @param {number} k - The number of hash functions used to compute this Bloom filter.
     *
     */
    constructor(bytes: Uint8Array, k: number);
    /**
     * Return the Bloom filter data structure represented as a {@link bigint} value.
     *
     * @returns {bigint} - The Bloom filter data structure represented as a {@link bigint} value.
     */
    get bi(): bigint;
    /**
     * Return the Bloom filter data structure represented as a {@link number} value.
     *
     * @returns {bigint} - The Bloom filter data structure represented as a {@link number} value.
     *
     * @throws InvalidDataType if the data structure of the bloom filter can't be represented as a number
     * because underflow or overflow number safe integer range according
     * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
     *
     * @remarks Preferably use {@link bi} because the Bloom filter data structure can always be represented as a {@link bigint} value.
     */
    get n(): number;
    /**
     * Compare the current BloomFilter instance with another BloomFilter instance according their
     * * {@link bytes} data structure first,
     * * {@link k} if the data structures are equal.
     *
     * @param {BloomFilter} that - The BloomFilter instance to compare with.
     *
     * @return {number} - Returns a negative number if the current instance is less than the provided instance,
     *                   returns zero if they are equal, and returns a positive number if the current instance is greater than the provided instance.
     */
    compareTo(that: BloomFilter): number;
    /**
     * Checks if the current BloomFilter instance is equal to another BloomFilter instance.
     *
     * @param {BloomFilter} that - The other BloomFilter instance to compare with.
     *
     * @return {boolean} - Returns true if the current BloomFilter instance is equal to the other BloomFilter instance, otherwise returns false.
     */
    isEqual(that: BloomFilter): boolean;
    /**
     * Checks if the specified key may be contained within this Bloom filter or surely isn't.
     *
     * @param {Hex|Uint8Array} key - The key to check. It can be either a Hex object or a Uint8Array.
     *
     * @return {boolean} Returns true if this Bloom filter may contain the key, otherwise returns false.
     *
     * @remarks False positive matches are possible, but false negatives are not.
     * @remarks Security auditable method, depends on
     * * {@link hash}.
     */
    contains(key: Hex | Uint8Array): boolean;
    /**
     * Calculates the optimal number of bits per key (`m` in math literature) based
     * on the number of hash functions (`k` in math literature) used to generate the Bloom Filter.
     *
     * Mathematically, `m` is approximated as `(k / ln(2))` which is simplified
     * to the higher integer close to `(m / 0.69)` for computational efficiency.
     * It also ensures that `k` is within a practical range [1, 30], hence the function
     * - returns `2` for `k = 1`,
     * - returns `44` for `k >= 30`.
     *
     * @param {number} k - The number of keys.
     *
     * @return {number} - The number of bits per key.
     */
    static computeBestBitsPerKey(k: number): number;
    /**
     * Calculates the optimal number of hash functions (`k` in math literature)
     * based on bits per key (`m` in math literature).
     *
     * Mathematically, `k` is approximated as `(m * ln(2))` which is simplified
     * to the lower integer close to `(m * 0.69)` for computational efficiency.
     * It also ensures that `k` stays within a practical range [1, 30].
     *
     * @param m - The number of bits per key.
     *
     * @returns The calculated optimal `k` value.
     */
    static computeBestHashFunctionsQuantity(m: number): number;
    /**
     * Checks if the current BloomFilter instance is possible to join with another BloomFilter instance.
     *
     * @param {BloomFilter} other - The BloomFilter instance to check if it is possible to join with the current instance.
     *
     * @return {boolean} - Returns true if the BloomFilter instances have the same 'k' value and 'bytes' length, false otherwise.
     */
    isJoinable(other: BloomFilter): boolean;
    /**
     * Joins the current BloomFilter with another BloomFilter by performing a bitwise OR operation on the
     * data structures of the filters.
     * Both filters must have been generated with the same number of hash functions, and they must have the same length.
     *
     * @param other - The BloomFilter to join with.
     *
     * @returns A new BloomFilter that represents the result of the join operation.
     *          They keys made this and `other` filter may belong to the returned filter.
     *          Any key not part of the joined filter surely doesn't belong to the returned filter.
     *
     * @throws {InvalidOperation} If the k values of the BloomFilters are different.
     * @throws {InvalidOperation} If the length of the byte arrays are different.
     */
    join(other: BloomFilter): BloomFilter;
    /**
     * Creates a new instance of BloomFilterBuilder and adds the specified keys to it.
     * * Call {@link BloomFilterBuilder.add} to add more keys.
     * * Call {@link BloomFilterBuilder.build} to create a new Bloom filter once
     *
     * @param {...(Hex[] | Uint8Array[])} keys - The keys to be added to the BloomFilterBuilder.
     *
     * @returns {BloomFilterBuilder} - A new instance of BloomFilterBuilder with the specified keys added.
     *
     * @remarks Security auditable method, depends on
     * * {@link BloomFilterBuilder.add}.
     */
    static of(...keys: Hex[] | Uint8Array[]): BloomFilterBuilder;
}
/**
 * The `BloomFilterBuilder` class provides methods for constructing a Bloom filter,
 * This builder class allows you to add keys to the filter and specify its `m` (bits per key) and `k` (hash functions)
 * parameters before building it.
 *
 * @see {BloomFilter.of}
 *
 */
declare class BloomFilterBuilder {
    /**
     * The default value number of hash functions used to create {@link BloomFilter} instances.
     */
    private static readonly DEFAULT_K;
    /**
     * Map each element of the keys as likely part of the data structure of the Bloom filter to build.
     * Each key is mapped in `m` bits using `k` hash functions.
     *
     * @see {hash}
     */
    private readonly hashMap;
    /**
     * Adds one or more keys to the Bloom filter to create.
     *
     * @param {Hex[] | Uint8Array[]} keys - The keys to be added to Bloom filter to create.
     *
     * @return {this} - Returns this {@link BloomFilterBuilder} instance, the {@link this.hashMap} is updated to
     * map the keys presence in the filter data structure.
     *
     * @remarks Security auditable method, depends on
     * * {@link hash}.
     */
    add(...keys: Hex[] | Uint8Array[]): this;
    /**
     * Builds a Bloom filter with the specified parameters and returns it.
     *
     * @param k - The number of hash functions to use in the Bloom filter.  to BloomFilterBuilder.DEFAULT_K.
     * @param m - The number of bits per key in the Bloom filter. Defaults to the value computed by BloomFilter.computeBestBitsPerKey(k).
     *
     * @return The built Bloom filter.
     */
    build(k?: number, m?: number): BloomFilter;
}

/**
 * Abstract class representing a coin, implementing the Currency interface.
 */
declare abstract class Coin implements Currency {
    /**
     * Represent coin {@link code} denomination.
     */
    private readonly _code;
    /**
     * Represent the coin {@link value}.
     *
     * @type {FixedPointNumber}
     */
    private readonly _value;
    /**
     * Creates an instance of the class with the specified code and value.
     *
     * @param {Txt} code - The code associated with this instance.
     * @param {FixedPointNumber} value - The value associated with this instance.
     */
    protected constructor(code: Txt, value: FixedPointNumber);
    /**
     * Return the code as a Txt object.
     *
     * @return {Txt} The code object
     *
     * @remarks Since currency codes likely use Unicode composite symbols,
     * {@link Txt} type enforce the representation of the code is normalized.
     */
    get code(): Txt;
    /**
     * Return the current value as an FixedPointNumber (Fixed-Point Number).
     *
     * @return {FixedPointNumber} The current value in Fixed-Point Number format.
     */
    get value(): FixedPointNumber;
    /**
     * Returns the integer part of the FixedPointNumber {@link value}.
     *
     * @return {bigint} the integer part of this FixedPointNumber {@link value}.
     *
     * @throws {InvalidOperation} If the {@link value} is not finite.
     *
     * @remarks Do not use for financial math: apply {@link FixedPointNumber} methods instead.
     */
    get bi(): bigint;
    /**
     * Returns the array of bytes representing the *Normalization Form Canonical Composition*
     * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)
     * of the textual expression '{@link value} {@link code}'.
     */
    get bytes(): Uint8Array;
    /**
     * Return this {@linl value} approximated as {@link number}.
     *
     * @remarks Do not use for financial math: apply {@link FixedPointNumber} methods instead.
     */
    get n(): number;
    /**
     * Compares this Currency object with another Currency object for order.
     *
     * @param {Currency} that - The Currency object to be compared.
     * @return {number} A negative integer, zero, or a positive integer as this Currency
     *     is less than, equal to, or greater than the specified Currency.
     * @throws {InvalidDataType} If the currency codes do not match.
     */
    compareTo(that: Currency): number;
    /**
     * Determines if this Currency object is equal to another Currency object.
     *
     * @param {Currency} that - The Currency object to compare with the current instance.
     * @return {boolean} - `true` if the objects are considered equal, otherwise `false`.
     */
    isEqual(that: Currency): boolean;
    /**
     * Returns the textual representation of this currency as
     * '{@link value} {@link code}'.
     *
     * @return A string that contains the value and code properties of the object.
     */
    toString(): string;
}

/**
 * Enumeration representing units (i.e. order of magnitude)
 * of cryptocurrency (e.g., ETH or VET).
 * Each unit is defined by its name and its corresponding decimal place shift.
 * The decimal place shift if the exponent of the power of 10 to multiply
 * a value expressed in the name unit to result in the equivalent value
 * expressed in `wei` unit.
 *
 * @remarks The unit `ether` refers to an order of magnitude, not to the
 * `ETH` cryptocurrency, albeit 1 ETH = 10E18 wei in
 * [scientific notation](https://en.wikipedia.org/wiki/Scientific_notation).
 *
 * @enum {number}
 */
declare enum Units {
    /**
     * 1 ether = 1,000,000,000,000,000,000 wei. 0 fractional digits FixedPointNumber.
     */
    wei = 0,
    /**
     * 1 ether = 1,000,000,000,000,000 kwei. 3 fractional digits FixedPointNumber.
     */
    kwei = 3,
    /**
     * 1 ether = 1,000,000,000,000 mwei. 6 fractional digits FixedPointNumber.
     */
    mwei = 6,
    /**
     * 1 ether = 1,000,000,000 gwei. 9 fractional digits FixedPointNumber.
     */
    gwei = 9,
    /**
     * 1 ether = 1,000,000,000 szabo. 12 fractional digits FixedPointNumber.
     */
    szabo = 12,
    /**
     * 1 ether = 1,000,000 finney. 15 fractional digits FixedPointNumber.
     */
    finney = 15,
    /**
     * 18 fractional diguts FixedPointNumber.
     */
    ether = 18
}
/**
 * Namespace for unit conversion functions,
 * providing the same functionalities of
 * [ethers v6 Unit Conversion](https://docs.ethers.org/v6/api/utils/#about-units).
 */
declare namespace Units {
    /**
     * Convert a value expressed in {@link Units.wei} as a string
     * representing the same value expressed in {@link Units.ether}.
     *
     * @param {FixedPointNumber} wei - The value in {@link Units.wei}.
     * @return {string} The formatted string representing the value in
     * {@link Units.ether}.
     *
     * @remarks The term `ether` refers to the order of magnitude 10E18,
     * not to the `ETH` cryptocurrency.
     *
     * @see [ethers formatEther](https://docs.ethers.org/v6/api/utils/#formatEther)
     */
    function formatEther(wei: FixedPointNumber): string;
    /**
     * Convert a value expressed in {@link Units.wei} as a string
     * representing the same value expressed in `unit`.
     *
     * @param {FixedPointNumber} wei - The value in {@link Units.wei}.
     * @param {Units} unit The order of magnitude to express the `wei` value.
     * @return {string} The formatted string representing the value
     * in the named `unit`.
     *
     * @remarks The term `ether` refers to the order of magnitude 10E18,
     * not to the `ETH` cryptocurrency.
     *
     * @see [ethers formatUnits](https://docs.ethers.org/v6/api/utils/#formatUnits)
     */
    function formatUnits(wei: FixedPointNumber, unit?: Units): string;
    /**
     * Parse the decimal string expressing a value in {@link Units.ether}
     * to return a {@link FixedPointNumber} value expressed in {@link Units.wei}.

     * @param ether = The representation of a numeric value expressed
     * in {@link Units.ether}.
     * @return The equivalent value in {@link Units.wei}.
     *
     * @throws {InvalidDataType} If `exp` is not a numeric expression.
     *
     * @remarks The term `ether` refers to the order of magnitude 10E18,
     * not to the `ETH` cryptocurrency.
     *
     * @see [ethers parseEther](https://docs.ethers.org/v6/api/utils/#parseEther)
     */
    function parseEther(ether: string): FixedPointNumber;
    /**
     * Parse the decimal string expressing a value in the named `unit`
     * ro return a {@link FixedPointNumber} value expressed in {@link Units.wei}.

     * @param {string} exp - The representation of a numeric value expressed
     * in {@link Units.ether}.
     * @param {Units} unit - The order of magnitude to use to parse the `exp`
     * representation.
     *
     * @throws {InvalidDataType} If `exp` is not a numeric expression.
     *
     * @remarks The term `ether` refers to the order of magnitude 10E18,
     * not to the `ETH` cryptocurrency.
     *
     * @see [ethers parseUnits](https://docs.ethers.org/v6/api/utils/#parseUnits)
     */
    function parseUnits(exp: string, unit?: Units): FixedPointNumber;
}

/**
 * Represents a
 * [VeChain VET](https://docs.vechain.org/introduction-to-vechain/dual-token-economic-model/vechain-vet)
 * monetary amount.
 *
 * @extends Coin
 */
declare class VET extends Coin {
    /**
     * The code for VET is the sequence of Unicode
     * - U+1D64D - mathematical double strike capital letter 'V',
     * - U+039F - Greek capital letter 'Xi',
     * - U+0054 - Latin capital letter 'T'.
     */
    static readonly CODE: Txt;
    /**
     * Wei fractional digits to express this value.
     */
    private static readonly WEI_FD;
    /**
     * Represents this monetary amount in terms of {@link Units.wei}.
     *
     * @type {bigint}
     */
    readonly wei: bigint;
    /**
     * Create a new instance with the given `value`.
     *
     * @param {FixedPointNumber} value The value to be used for initializing the instance.
     */
    protected constructor(value: FixedPointNumber);
    /**
     * Return a new VET instance with the specified value and unit.
     *
     * @param {bigint | number | string | FixedPointNumber} value - The numerical value for the VET instance.
     * @param {Units} unit - The unit for the value.
     *                     Defaults to {@link Units.ether} if not provided.
     * @return {VET} A new VET instance with the provided value and unit.
     *
     * @throws {InvalidDataType} If `value` is not a numeric expression.
     */
    static of(value: bigint | number | string | FixedPointNumber, unit?: Units): VET;
}

/**
 * Represents a
 * [VeChain VeThor](https://docs.vechain.org/introduction-to-vechain/dual-token-economic-model/vethor-vtho)
 * monetary amount.
 *
 * @extends Coin
 */
declare class VTHO extends Coin {
    /**
     * The code for VET is the sequence of Unicode
     * - U+1D64D - mathematical double strike capital letter 'V',
     * - U+0054 - Latin capital letter 'T',
     * - U+0048 - Latin capital letter 'H',
     * - U+004F - Latin capital letter 'O'.
     */
    static readonly CODE: Txt;
    /**
     * Wei fractional digits to express this value.
     */
    private static readonly WEI_FD;
    /**
     * Represents this monetary amount in terms of {@link Units.wei}.
     *
     * @type {bigint}
     */
    readonly wei: bigint;
    /**
     * Create a new instance with the given `value`.
     *
     * @param {FixedPointNumber} value The value to be used for initializing the instance.
     */
    protected constructor(value: FixedPointNumber);
    /**
     * Return a new VTHO instance with the specified value and unit.
     *
     * @param {bigint | number | string | FixedPointNumber} value - The numerical value for the VTHO instance.
     * @param {Units} unit - The unit for the value.
     *                       Defaults to {@link Units.ether} if not provided.
     * @return {VTHO} A new VTHO instance with the provided value and unit.
     *
     * @throws {InvalidDataType} If `value` is not a numeric expression.
     */
    static of(value: bigint | number | string | FixedPointNumber, unit?: Units): VTHO;
}

/**
 * Represents a valid input for the RLP (Recursive Length Prefix) encoding.
 * The RLP encoding is used to encode arbitrary binary data (nested arrays of bytes).
 *
 * @typeParam Input - A {@link @ethereumjs/rlp#Input} type.
 * @see {@link https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/rlp/src/index.ts}
 */
type RLPInput = Input;

/**
 * Represents an output from RLP decoding.
 * This type can either be a single Uint8Array (byte array) or a nested structure
 * of Uint8Array instances.
 *
 * @typeParam Uint8Array - A typed array of 8-bit unsigned integers.
 * @typeParam NestedUint8Array - A possibly nested array of Uint8Arrays.
 */
type RLPOutput = Uint8Array | NestedUint8Array;

/**
 * Represents a complex RLP object.
 * This type allows for recursive nesting of RLPInput or further RLPComplexObjects,
 * allowing the definition of complex structures.
 *
 * @typeParam RLPInput - A valid RLP input type.
 * @typeParam RLPComplexObject - Recursive type to enable nesting of complex objects.
 */
interface RLPComplexObject {
    [key: string]: RLPInput | RLPComplexObject | RLPComplexObject[];
}

/**
 * Represents a valid RLP object.
 * It is a dictionary-like object where keys are strings and values can be
 * a valid RLP input type or a complex RLP object (which can be further nested).
 *
 * @typeParam RLPValueType - A type that represents all valid RLP values.
 */
type RLPValidObject = Record<string, RLPValueType>;

/**
 * Represents all valid RLP value types.
 * This type union is used to simplify the definition of valid value types within
 * RLP object structures, supporting single inputs, complex objects, and arrays
 * of complex objects.
 *
 * @typeParam RLPInput - A valid RLP input type.
 * @typeParam RLPComplexObject - A valid complex RLP object.
 */
type RLPValueType = RLPInput | RLPComplexObject | RLPComplexObject[];

/**
 * `DataOutput` Interface - Provides an encoding mechanism to convert data into a Uint8Array.
 */
interface DataOutput {
    encode: () => Uint8Array;
}

/**
 * `BufferOutput` Interface - Provides a decoding mechanism to convert a Buffer back into data.
 */
interface BufferOutput {
    decode: () => RLPInput;
}

/**
 * `RLPProfile` Interface - Describes the profile of the RLP encoding.
 */
interface RLPProfile {
    name: string;
    kind: ScalarKind | ArrayKind | StructKind;
}
/**
 * `ArrayKind` Interface - Describes an array-kind in the RLP encoding profile.
 */
interface ArrayKind {
    item: RLPProfile['kind'];
}
/**
 * `StructKind` Type - Describes a structured-kind in the RLP encoding profile using an array of `RLPProfile`.
 */
type StructKind = RLPProfile[];
/**
 * `ScalarKind` Abstract Class - A base for scalar kinds providing contract for data and buffer manipulations.
 */
declare abstract class ScalarKind {
    /**
     * Abstract method to handle data encoding.
     * @param data - The data to encode.
     * @param context - Contextual information for error messaging.
     * @returns An object providing a mechanism to encode the data into a Uint8Array.
     */
    abstract data(data: RLPInput | RLPValidObject, context: string): DataOutput;
    /**
     * Abstract method to handle buffer decoding.
     * @param buffer - The buffer to decode.
     * @param context - Contextual information for error messaging.
     * @returns An object providing a mechanism to decode the buffer back into data.
     */
    abstract buffer(buffer: Uint8Array, context: string): BufferOutput;
}

declare class RLP implements VeChainDataModel<RLP> {
    readonly encoded: Uint8Array;
    readonly decoded: RLPInput;
    protected constructor(data: RLPInput);
    protected constructor(data: Uint8Array);
    /**
     * Returns the bigint representation of the encoded data in the RLP instance.
     * @returns {bigint} The bigint representation of the encoded data.
     */
    get bi(): bigint;
    /**
     * Returns the encoded data as a Uint8Array.
     * @returns {Uint8Array} The encoded data.
     */
    get bytes(): Uint8Array;
    /**
     * Returns the number representation of the encoded data in the RLP instance.
     * @returns {number} The number representation of the encoded data.
     */
    get n(): number;
    /**
     * Compares the current RLP instance with another RLP instance.
     * @param {RLP} that The RLP instance to compare.
     * @returns 0 if the RLP instances are equal, -1/1 if they are not.
     */
    compareTo(that: RLP): number;
    /**
     * Relies on compareTo to check if the RLP instances are equal.
     * @param {RLP} that The RLP instance to compare.
     * @returns true if the RLP instances are equal, false otherwise.
     */
    isEqual(that: RLP): boolean;
    /**
     * Creates {@link Hex} instance from the RLP encoded value.
     * @returns {Hex} The Hex instance.
     */
    toHex(): Hex;
    /**
     * Returns an RLP instance from a plain value.
     * @param data - The plain data
     * @returns {RLP} The RLP instance.
     */
    static of(data: RLPInput): RLP;
    /**
     * Returns an RLP instancen from an encoded value.
     * @param {Uint8Array} encodedData - The RLP-encoded data.
     * @returns The decoded data or null if decoding fails.
     */
    static ofEncoded(encodedData: Uint8Array): RLP;
    /**
     * Handles the RLP packing of data.
     * Recursively processes through object properties or array elements to prepare data for RLP encoding.
     *
     * @param obj - The object data to be packed.
     * @param profile - Profile for encoding structures.
     * @param context - Encoding context for error tracing.
     * @returns Packed data as RLPInput.
     * @throws {InvalidRLP}
     *
     */
    protected static packData(obj: RLPValidObject, profile: RLPProfile, context: string): RLPInput;
    /**
     * Handles the RLP unpacking of data.
     * Recursively processes through packed properties or elements to prepare data post RLP decoding.
     *
     * @param packed - The packed data to be unpacked.
     * @param profile - Profile for decoding structures.
     * @param context - Decoding context for error tracing.
     * @returns Unpacked data as RLPValueType.
     * @throws {InvalidRLP}
     *
     */
    protected static unpackData(packed: RLPInput, profile: RLPProfile, context: string): RLPValueType;
}

/**
 * Class handling the profiling of RLP encoded/decoded objects.
 * Provides methods to encode and decode objects based on a provided RLP profile.
 */
declare class RLPProfiler extends RLP {
    readonly profile: RLPProfile;
    /**
     * Creates a new Profiler instance.
     * @param profile - Profile for encoding/decoding structures.
     */
    private constructor();
    /**
     * Creates an RLPProfiler instance from a valid object.
     * @param {RLPValidObject} validObject Object to be encoded.
     * @returns {RLPProfiler} RLPProfiler instance.
     */
    static ofObject(validObject: RLPValidObject, profile: RLPProfile): RLPProfiler;
    /**
     * Decodes an object following the provided profile.
     * @param encodedData Data to be decoded.
     * @param profile Profile for encoding/decoding structures.
     * @returns - Decoded data as RLPValueType.
     */
    static ofObjectEncoded(encodedData: Uint8Array, profile: RLPProfile): RLPProfiler;
    /**
     * Returns the decoded unpacked object.
     * @returns {RLPValueType} Decoded unpacked object.
     */
    get object(): RLPValueType;
}

/**
 * Validates and converts the input data to a BigInt.
 *
 * @param data - Either a number or a string representing a non-negative integer.
 * @param context - A string representing the context in which this function is used,
 *                 to create meaningful error messages.
 * @returns The input data converted to a BigInt.
 * @throws {InvalidRLP}
 */
declare const validateNumericKindData: (data: RLPInput, context: string) => bigint;
/**
 * Validates a buffer to ensure it adheres to constraints and does not contain
 * leading zero bytes which are not canonical representation in integers.
 *
 * @param {Uint8Array} buf - The buffer to validate.
 * @param {string} context - A string providing context for error messages.
 * @param {number} maxBytes - [Optional] An integer representing the maximum allowed length
 *                   of the buffer. If provided, an error will be thrown if buf is longer.
 * @throws {InvalidRLP}
 *
 * @private
 */
declare const assertValidNumericKindBuffer: (buf: Uint8Array, context: string, maxBytes?: number) => void;
/**
 * Encode a BigInt instance into a Buffer, ensuring it adheres to specific constraints.
 *
 * @param {bigint} bi - BigInt instance to encode.
 * @param {number | undefined} maxBytes - Maximum byte length allowed for the encoding. If undefined, no byte size limit is imposed.
 * @param {string} context - Contextual information for error messages.
 * @returns {Uint8Array} Encoded data.
 * @throws {InvalidRLP}
 */
declare const encodeBigIntToBuffer: (bi: bigint, maxBytes: number | undefined, context: string) => Uint8Array;
/**
 * Decode a Uint8Array into a number or hexadecimal string.
 * @param {Uint8Array} buffer - Instance to decode.
 * @returns A number if the decoded BigInt is a safe integer, otherwise returns a hexadecimal string.
 */
declare const decodeBufferToNumberOrHex: (buffer: Uint8Array) => number | string;

/**
 * Validates if the input is a proper hex string for HexBlobKind.
 *
 * @param data - The input data to validate.
 * @param context - Additional context for error handling.
 * @throws {InvalidRLP}
 */
declare const assertValidHexBlobKindData: (data: RLPInput, context: string) => void;

/**
 * Asserts that the data is a hex string of the correct length.
 *
 * @param data - The data to validate.
 * @param context - Descriptive context for error messages.
 * @param bytes - The expected number of bytes that the data can contain.
 * @throws {InvalidRLP}
 */
declare const assertFixedHexBlobKindData: (data: string, context: string, bytes: number) => void;
/**
 * Asserts that the buffer is of a specific length.
 *
 * @param {Uint8Array} buffer The buffer to validate.
 * @param {string} context Descriptive context for error messages.
 * @param {number} bytes The expected number of bytes that the buffer can contain.
 * @throws {InvalidRLP}
 */
declare const assertFixedHexBlobKindBuffer: (buffer: Uint8Array, context: string, bytes: number) => void;

/**
 * Asserts that the provided buffer is of a specific length and does not contain leading zeros.
 *
 * @param {Uint8Array} buffer - The buffer to validate.
 * @param {string} context - Descriptive context for error messages, usually representing the caller's identity.
 * @param {number} bytes - The expected maximum number of bytes that the buffer can contain.
 * @throws {InvalidRLP}
 */
declare const assertCompactFixedHexBlobBuffer: (buffer: Uint8Array, context: string, bytes: number) => void;
/**
 * Encodes a buffer by trimming leading zero bytes.
 * Finds the first non-zero byte and returns a new buffer starting from that byte. Returns an empty buffer if all bytes are zero.
 *
 * @param {Uint8Array} buffer - The buffer to be compacted.
 * @returns {Uint8Array} A Uint8Array instance compacted of leading zero bytes, or an empty Uint8Array if all bytes are zero.
 */
declare const encodeCompactFixedHexBlob: (buffer: Uint8Array) => Uint8Array;
/**
 * Decodes a buffer into a hexadecimal string, ensuring a specific total byte length by prepending zeros if necessary.
 * Calculates the number of missing bytes compared to the expected total and prepends the corresponding number of '0' characters to the hexadecimal string representation of the buffer.
 *
 * @param {Uint8Array} buffer The buffer to decode.
 * @param {number} bytes The expected total number of bytes in the final hexadecimal string (including leading zeros).
 * @returns A hexadecimal string with the necessary leading '0' characters to ensure the specified total byte length.
 */
declare const decodeBufferToHexWithLeadingZeros: (buffer: Uint8Array, bytes: number) => string;

/**
 * Represents a scalar kind with Buffer functionality.
 * This class extends the {@link ScalarKind} class.
 */
declare class BufferKind extends ScalarKind {
    /**
     * Encodes the input data into buffer format.
     *
     * @param {RLPInput} data The data to encode, expected to be of Uint8Array type.
     * @param {string} context Descriptive context for error messages
     * @returns {DataOutput} Object with an encode function.
     * @throws {InvalidRLP}
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer.
     *
     * @param {Uint8Array} buffer - The buffer to decode, expected to be of buffer type.
     * @returns BufferOutput object with a decode function.
     * @throws {InvalidRLP}
     */
    buffer(buffer: Uint8Array): BufferOutput;
}

/**
 * Represents a scalar kind with numeric functionality.
 * This class extends the {@link ScalarKind} class.
 */
declare class NumericKind extends ScalarKind {
    readonly maxBytes?: number | undefined;
    /**
     * Constructs a new instance of NumericKind.
     *
     * @param maxBytes - Optional parameter that specifies the maximum number of bytes that numeric data can occupy when encoded.
     */
    constructor(maxBytes?: number | undefined);
    /**
     * Encodes the input data into numeric format and ensures it doesn't exceed the maximum bytes, if specified.
     *
     * @param data - The data to encode, expected to be numeric.
     * @param context - Descriptive context for error messages
     * @returns DataOutput object with an encode function.
     * @throws Will throw an error if data validation fails or encoding issues occur.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a number or hexadecimal string, ensuring it meets numeric data constraints.
     *
     * @param {Uint8Array} buffer - The buffer to decode, containing numeric data.
     * @param context - Descriptive context for error messages.
     * @returns BufferOutput object with a decode function.
     * @throws Will throw an error if buffer validation fails.
     */
    buffer(buffer: Uint8Array, context: string): BufferOutput;
}

/**
 * Represents a scalar kind with hex blob functionality.
 * This class extends the {@link ScalarKind} class.
 *
 * @remarks
 * A hex blob is a hex string that is prefixed with '0x' and has even length.
 */
declare class HexBlobKind extends ScalarKind {
    /**
     * Encodes the input data into a Uint8Array.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Uint8Array.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string.
     *
     * @param buffer - The buffer to decode.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string.
     */
    buffer(buffer: Uint8Array, _context: string): BufferOutput;
}

/**
 * Represents a hex blob kind with fixed bytes size functionality.
 * This class extends the {@link HexBlobKind} class.
 */
declare class FixedHexBlobKind extends HexBlobKind {
    readonly bytes: number;
    /**
     * Creates a new instance of the {@link FixedHexBlobKind} class.
     * @param bytes - The number of bytes the blob must have.
     */
    constructor(bytes: number);
    /**
     * Encodes the input data into a Uint8Array with validation against fixed size.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Uint8Array.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string with validation against fixed size.
     *
     * @param buffer - The buffer to decode.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string.
     */
    buffer(buffer: Uint8Array, context: string): BufferOutput;
}

/**
 * Represents a fixed hex blob kind with optional data functionality.
 * This class extends the {@link FixedHexBlobKind} class.
 */
declare class OptionalFixedHexBlobKind extends FixedHexBlobKind {
    /**
     * Encodes the input data (which can be null or undefined) into a Uint8Array.
     *
     * @param data - The data to encode, can be null or undefined.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Uint8Array.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string or null if the buffer is empty.
     *
     * @param buffer - The buffer to decode, can be empty.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string or null.
     */
    buffer(buffer: Uint8Array, context: string): BufferOutput;
}

/**
 * Represents a fixed hex blob kind with zero trimming and padding functionality.
 * This class extends the {@link FixedHexBlobKind} class.
 */
declare class CompactFixedHexBlobKind extends FixedHexBlobKind {
    /**
     * Encodes the input data into a Uint8Array, trimming leading zeros.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Uint8Array.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a number or hexadecimal string, ensuring it meets the fixed size by padding with zeros.
     *
     * @param buffer - The buffer to decode, containing numeric data.
     * @param context - Descriptive context for error messages, usually representing the caller's identity.
     * @returns BufferOutput object with a decode function.
     * @throws Will throw an error if buffer validation fails.
     */
    buffer(buffer: Uint8Array, context: string): BufferOutput;
}

/**
 * Represents the result of an [BLAKE](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) [BlAKE2B 256](https://www.blake2.net/) hash operation.
 *
 * @extends HexUInt
 */
declare class Blake2b256 extends HexUInt {
    /**
     * Generates the [BLAKE](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) [BLAKE2B 256](https://www.blake2.net/) hash of the given input.
     *
     * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
     *
     * @returns {Sha256} - The [BLAKE2B 256](https://www.blake2.net/) hash of the input value.
     *
     * @throws {InvalidOperation} - If a hash error occurs.
     *
     * @remarks Security auditable method, depends on
     * * [`nh_blake2b.create(...).update(...).digest(...)`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).
     */
    static of(exp: bigint | number | string | Uint8Array | Hex): Blake2b256;
}

/**
 * Represents the result of an [SHA-3](https://en.wikipedia.org/wiki/SHA-3) [KECCAK 256](https://keccak.team/keccak.html) hash operation.
 *
 * @extends HexUInt
 */
declare class Keccak256 extends HexUInt {
    /**
     * Generates the [SHA-3](https://en.wikipedia.org/wiki/SHA-3) [KECCAK 256](https://keccak.team/keccak.html) hash of the given input.
     *
     * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
     *
     * @returns {Sha256} - The [KECCAK 256](https://keccak.team/keccak.html) hash of the input value.
     *
     * @throws {InvalidOperation} - If a hash error occurs.
     *
     * @remarks Security auditable method, depends on
     * * [`nh_keccak_256`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).
     */
    static of(exp: bigint | number | string | Uint8Array | Hex): Keccak256;
}

/**
 * Represents the result of an [SHA256](https://en.wikipedia.org/wiki/SHA-2) hash operation.
 *
 * @extends HexUInt
 * @implements Hash
 */
declare class Sha256 extends HexUInt {
    /**
     * Generates the [SHA 256](https://en.wikipedia.org/wiki/SHA-2) hash of the given input.
     *
     * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.
     *
     * @returns {Sha256} - The [SHA256](https://en.wikipedia.org/wiki/SHA-2) hash of the input value.
     *
     * @throws {InvalidOperation} - If a hash error occurs.
     *
     * @remarks Security auditable method, depends on
     * * [`nh_sha256.sha256`](https://github.com/paulmillr/noble-hashes#sha2-sha256-sha384-sha512-and-others).
     */
    static of(exp: bigint | number | string | Uint8Array): Sha256;
}

/**
 * Type of the wordlist size.
 * Every 4 bytes produce 3 words.
 */
type WordlistSizeType = 12 | 15 | 18 | 21 | 24;
/**
 * Size of the mnemonic words in bytes.
 */
type WordListRandomGeneratorSizeInBytes = 16 | 20 | 24 | 28 | 32;
/**
 * The Mnemonic class provides functionality related to mnemonic phrases, including encoding to bytes,
 * generating, validating, and deriving keys from mnemonic words based on the BIP39 standard.
 * It implements the VeChainDataModel interface.
 *
 * @implements VeChainDataModel
 */
declare class Mnemonic implements VeChainDataModel<Mnemonic> {
    /**
     * A TextEncoder instance used for encoding text to bytes.
     *
     * @type {TextEncoder}
     */
    private static readonly ENCODER;
    /**
     * Throws an exception because the mnemonic cannot be represented as a big integer.
     * @returns {bigint} The BigInt representation of the mnemonic.
     * @throws {InvalidOperation} The mnemonic cannot be represented as a bigint.
     * @override {@link VeChainDataModel#bi}
     * @remark The conversion to BigInt is not supported for a mnemonic.
     */
    get bi(): bigint;
    /**
     * Generates a mnemonic as encoded bytes.
     *
     * @returns {Uint8Array} The bytes representation of the words with spaces.
     */
    get bytes(): Uint8Array;
    /**
     * Throws an exception because the mnemonic cannot be represented as a number.
     * @returns {bigint} The number representation of the mnemonic.
     * @throws {InvalidOperation} The mnemonic cannot be represented as a number.
     * @override {@link VeChainDataModel#n}
     * @remark The conversion to number is not supported for a mnemonic.
     */
    get n(): number;
    /**
     *
     * @param that - The mnemonic to compare with.
     */
    compareTo(_that: Mnemonic): number;
    isEqual(_that: Mnemonic): boolean;
    /**
     * Convert the number of words to the corresponding strength.
     *
     * @param numberOfWords - The number of words.
     *
     * @returns {number} The corresponding strength.
     *
     * @throws {InvalidDataType} If the number of words is not valid.
     */
    private static wordsNoToStrength;
    /**
     * Derives a private key from a given list of
     * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
     * and a derivation path as in the examples.
     *
     * @example `m/0` (default)
     * @example `m/0/2`
     * @example `m/0/2/4/6`
     *
     * @param {string[]} words - The set of words used for mnemonic generation.
     * @param {string} [path='m/0'] - The derivation path from the current node.
     *
     * @returns {Uint8Array} - The derived private key as a Uint8Array.
     *
     * @throws {InvalidHDKey}
     *
     * @remarks Security auditable method, depends on
     * * {@link HDKey}.
     */
    static toPrivateKey(words: string[], path?: string): Uint8Array;
    /**
     * Generates a
     * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
     * phrase using the specified wordlist size and random generator.
     *
     * @param {WordlistSizeType} wordlistSize - The number of words to generate the mnemonic.
     * @param {function} [randomGenerator] - The random generator function used to generate the entropy.
     *
     * @returns {Mnemonic} The generated mnemonic.
     *
     * @throws {InvalidDataType} If the number of words is not valid.
     *
     * @remarks Security auditable method, depends on
     * * [entropyToMnemonic](https://github.com/paulmillr/scure-bip39);
     * * [generateMnemonic](https://github.com/paulmillr/scure-bip39);
     * * `randomGenerator` - **Must provide a cryptographic secure source of entropy
     *    else any secure audit certification related with this software is invalid.**
     */
    static of(wordlistSize?: WordlistSizeType, randomGenerator?: (numberOfBytes: WordListRandomGeneratorSizeInBytes) => Uint8Array): string[];
    /**
     * Check if the given mnemonic words are valid.
     *
     * @param {string | string[]} words - The mnemonic words to check.
     *
     * @returns {boolean} true if the words are valid, false otherwise.
     *
     * @remarks Security auditable method, depends on
     * * [validateMnemonic](https://github.com/paulmillr/scure-bip39).
     */
    static isValid(words: string | string[]): boolean;
}

/**
 * Represents a hexadecimal numeric value compatible with the result of
 * [ethers](https://docs.ethers.org/v6/)
 * [utils.toQuantity](https://docs.ethers.org/v6/api/utils/#toQuantity) function.
 * This is most commonly used for JSON-RPC numeric values.
 *
 * @remarks A quantity instance:
 * * has not empty content,
 * * the hexadecimal representation removes any not meaningful zero on the left side of the expression,
 * * represents only positive integers.
 *
 * @extends HexUInt
 */
declare class Quantity extends HexUInt {
    /**
     * Creates a Quantity instance from a bigint or number given expression
     *
     * @param {bigint | number} exp - The value to be expressed as Quantity object:
     * * bigint must be positive;
     * * number must be positive, it is converted to bigint to create the Quantity.
     *
     * @returns {Quantity} - The new Quantity object.
     *
     * @throws {InvalidDataType} - If the provided expression is not a positive integer value.
     */
    static of(exp: bigint | number): Quantity;
}

/**
 * Represents a revision for a Thor transaction or block.
 *
 * @remarks The string representation of the revision is always expressed as a number in base 10.
 *
 * @extends Txt
 */
declare class Revision extends Txt {
    /**
     * Regular expression pattern for revision strings.
     * Revision strings can be one of the following:
     * - "best": indicating the best revision
     * - "finalized": indicating a finalized revision
     * - A positive numeric string indicating a specific revision
     *
     * @type {RegExp}
     */
    private static readonly REGEX_DECIMAL_REVISION;
    /**
     * Determines if the given value is valid.
     * This is true if the given value is
     * - "best" string or {@link Txt}: indicating the best revision;
     * - "finalized" string or {@link Txt}: indicating a finalized revision;
     * - a positive number;
     * - a positive numeric decimal or `0x` prefixed hexadecimal string indicating a specific revision,
     *
     * @param {bigint | number | string | Hex | Txt} value - The value to be validated.
     * @returns {boolean} - Returns `true` if the value is valid, `false` otherwise.
     */
    static isValid(value: number | string): boolean;
    /**
     * Creates a new Revision object from the given value.
     *
     * @param {bigint | number | string | Uint8Array | Hex } value - The value to create the Revision from:
     * * {@link Hex} must be positive;
     * * {@link Uint8Array} is decoded as a string: see {@link Txt.of}.
     *
     * @returns {Revision} - The created Revision object.
     *
     *  @throws {InvalidDataType} if the given value is not a valid revision: see {@link isValid}.
     *
     * @remarks The string representation of the revision is always expressed as a number in base 10.
     * @remarks The {@link Uint8Array} value is decoded as a string content: see {@link Txt.of}.
     */
    static of(value: bigint | number | string | Uint8Array | Hex): Txt;
    /**
     * Return the `best` revision instance.
     */
    static readonly BEST: Revision;
    /**
     * Return the `finalized` revision instance.
     */
    static readonly FINALIZED: Revision;
}

/**
 * The BlockId class represents a Thor block ID value, which is a hexadecimal positive integer having 64 digits.
 *
 * @extends HexInt
 */
declare class BlockId extends HexUInt {
    /**
     * Number of digits to represent a Thor block ID value.
     *
     * @remarks The `0x` prefix is excluded.
     *
     * @type {number}
     */
    private static readonly DIGITS;
    /**
     * Constructs a BlockId object with the provided hexadecimal value.
     *
     * @param {HexUInt} huint - The hexadecimal value representing the BlockId.
     */
    protected constructor(huint: HexUInt);
    /**
     * Check if the given expression is a valid BlockId.
     *
     * @param {string} exp - The expression to be validated.
     *
     * @return {boolean} Returns true if the expression is a valid BlockId, false otherwise.
     */
    static isValid(exp: string): boolean;
    /**
     * Determines whether the given string is a valid hex number prefixed with '0x'.
     *
     * @param {string} exp - The hex number to be checked.
     *
     *  @returns {boolean} - True if the hex number is valid, false otherwise.
     */
    static isValid0x(exp: string): boolean;
    /**
     * Creates a new BlockId object from the given expression.
     *
     * @param {bigint | number | string | Hex | Uint8Array} exp - The expression to create the BlockId from.
     *     It can be one of the following types:
     *     - bigint: A BigInteger value that represents the BlockId.
     *     - number: A number value that represents the BlockId.
     *     - string: A string value that represents the BlockId.
     *     - HexUInt: A HexUInt object that represents the BlockId.
     *     - Uint8Array: A Uint8Array object that represents the BlockId.
     *
     * @returns {BlockId} - A new BlockId object created from the given expression.
     *
     * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.
     */
    static of(exp: bigint | number | string | Uint8Array | HexUInt): BlockId;
}
/**
 * This class is an alias of {@link BlockId} for back compatibility.
 */
declare class ThorId extends BlockId {
    /**
     * Constructs an instance of the class with the specified block ID.
     *
     * @param {BlockId} blockId - The unique identifier for the block.
     */
    protected constructor(blockId: BlockId);
    /**
     * See {@link BlockId.of}.
     */
    static of(exp: bigint | number | string | Uint8Array | HexUInt): ThorId;
}

/**
 * Options for creating a clause.
 */
interface ClauseOptions {
    /**
     * Optional comment for the clause, helpful for displaying what the clause is doing.
     */
    comment?: string;

    /**
     * Optional ABI for the contract method invocation.
     */
    includeABI?: boolean;
}

/**
 * Represents the parameters required for deployment.
 * @interface DeployParams
 */
interface DeployParams {
    /**
     * An array of types associated with the deployment parameters.
     * @type {string | AbiParameter[]}
     */
    types: string | AbiParameter[];

    /**
     * An array of values corresponding to the deployment parameters.
     * @type {string[]}
     */
    values: string[];
}

/**
 * Simple type for transaction clause.
 */
interface TransactionClause {
    /**
     * Destination address where:
     * * transfer token to or
     * * invoke contract method on.
     *
     * @note Set null destination to deploy a contract.
     */
    to: string | null;

    /**
     * Amount of token to transfer to the destination
     */
    value: string | number;

    /**
     * Input data for contract method invocation or deployment
     */
    data: string;

    /**
     * Optional comment for the clause, helpful for displaying what the clause is doing.
     */
    comment?: string;

    /**
     * Optional ABI for the contract method invocation.
     */
    abi?: string;
}

/**
 * This class represent a transaction clause.
 *
 * @extends {TransactionClause}
 */
declare class Clause implements TransactionClause {
    /**
     * Used internally in {@link Clause.callFunction}.
     */
    private static readonly FORMAT_TYPE;
    /**
     * Used internally to tag a transaction not tranferring token amount.
     */
    private static readonly NO_VALUE;
    /**
     * Used internally to tag a transaction without data.
     */
    private static readonly NO_DATA;
    /**
     * Used internally in {@link Clause.transferNFT} method.
     */
    private static readonly TRANSFER_NFT_FUNCTION;
    /**
     * Used internally in {@link Clause.transferToken} method.
     */
    private static readonly TRANSFER_TOKEN_FUNCTION;
    /**
     * Represents the address where:
     * - transfer token to, or
     * - invoke contract method on.
     */
    readonly to: string | null;
    /**
     * Return the hexadecimal expression of the amount of VET or VTHO
     * token in {@link Units.wei} to transfer to the destination.
     *
     * @see {Clause.callFunction}
     * @see {Clause.transferToken}
     * @see {Clause.transferVET}
     */
    readonly value: string;
    /**
     * Return the hexadecimal expression of the encoding of the arguments
     * of the called function of a smart contract.
     */
    readonly data: string;
    /**
     * An optional comment to describe the purpose of the clause.
     */
    readonly comment?: string;
    /**
     * An optional  Application Binary Interface (ABI) of the called
     * function of a smart contract.
     */
    readonly abi?: string;
    /**
     * Creates an instance of the class.
     *
     * @param {string|null} to - The address to transfer token
     * or the smart contract to call, can be null.
     * @param {string} value - The token amount being transferred in wei units
     * as hexadecimal expression.
     * @param {string} data - Arguments of the smart contract function called
     * as encoded as a hexadecimal expression
     * @param {string} [comment] - An optional comment.
     * @param {string} [abi] - An optional ABI string.
     */
    protected constructor(to: string | null, value: string, data: string, comment?: string, abi?: string);
    /**
     * Return the amount of {@link VET} or {@link VTHO} token
     * in {@link Units.wei} to transfer to the destination.
     *
     * @return {FixedPointNumber} The amount as a fixed-point number.
     */
    amount(): FixedPointNumber;
    /**
     * Return a new clause to call a function of a smart contract.
     *
     * @param {Address} contractAddress - The address of the smart contract.
     * @param {ABIFunction} functionAbi - The ABI definition of the function to be called.
     * @param {unknown[]} args - The arguments for the function.
     * @param {VET} [amount=VET.of(FixedPointNumber.ZERO)] - The amount of VET to be sent with the transaction calling the function.
     * @param {ClauseOptions} [clauseOptions] - Optional clause settings.
     * @return {Clause} A clause object to call the function in a transaction.
     * @throws {InvalidDataType} Throws an error if the amount is not a finite positive value.
     */
    static callFunction(contractAddress: Address, functionAbi: ABIFunction, args: unknown[], amount?: VET, clauseOptions?: ClauseOptions): Clause;
    /**
     * Returns a new clause to deploy a smart contract.
     *
     * @param {HexUInt} contractBytecode - The bytecode of the contract to be deployed.
     * @param {DeployParams} [deployParams] - Optional parameters to pass to the smart contract constructor.
     * @param {ClauseOptions} [clauseOptions] - Optional clause settings.
     * @return {Clause} The clause to deploy the smart contract as part of a transaction.
     */
    static deployContract(contractBytecode: HexUInt, deployParams?: DeployParams, clauseOptions?: ClauseOptions): Clause;
    /**
     * Transfers an NFT from the sender to the recipient.
     *
     * @param {Address} contractAddress - The address of the NFT contract.
     * @param {Address} senderAddress - The address of the current owner (sender) of the NFT.
     * @param {Address} recipientAddress - The address of the new owner (recipient) of the NFT.
     * @param {HexUInt} tokenId - The unique identifier of the NFT to be transferred.
     * @param {ClauseOptions} [clauseOptions] - Optional clause settings.
     * @return {Clause} The clause object representing the transfer operation as part of a transaction.
     */
    static transferNFT(contractAddress: Address, senderAddress: Address, recipientAddress: Address, tokenId: HexUInt, clauseOptions?: ClauseOptions): Clause;
    /**
     * Return a new clause to transfers the specified amount of
     * [VIP180](https://docs.vechain.org/introduction-to-vechain/dual-token-economic-model/vethor-vtho#vip180-vechains-fungible-token-standard)
     * token.
     *
     * @param {Address} tokenAddress - The address of the VIP180 token.
     * @param {Address} recipientAddress - The address of the recipient.
     * @param {VTHO} amount - The amount of token to be transferred.
     * @param {ClauseOptions} [clauseOptions] - Optional clause settings.
     * @return {Clause} The clause to transfer VIP180 tokens as part of a transaction.
     * @throws {InvalidDataType} Throws an error if the amount is not a positive integer.
     *
     * @see VTHO.transferTokenTo
     */
    static transferToken(tokenAddress: Address, recipientAddress: Address, amount: VTHO, clauseOptions?: ClauseOptions): Clause;
    /**
     * Return a new clause to transfers VET to a specified recipient address.
     *
     * @param {Address} recipientAddress - The address of the recipient.
     * @param {VET} amount - The amount of VET to transfer.
     * @param {ClauseOptions} [clauseOptions] - Optional clause settings.
     * @return {Clause} - The clause object to transfer VET as part of a transaction.
     * @throws {InvalidDataType} - If the amount is not a finite positive value.
     *
     * @see VET.transferTo
     */
    static transferVET(recipientAddress: Address, amount: VET, clauseOptions?: ClauseOptions): Clause;
}

/**
 * Type for transaction body.
 */
interface TransactionBody {
    /**
     * Last byte of genesis block ID
     */
    chainTag: number;

    /**
     * 8 bytes prefix of some block's ID
     */
    blockRef: string;

    /**
     * Constraint of time bucket
     */
    expiration: number;

    /**
     * Array of clauses
     */
    clauses: TransactionClause[];

    /**
     * Coefficient applied to base gas price [0,255]
     */
    gasPriceCoef: number;

    /**
     * Max gas provided for execution
     */
    gas: string | number;

    /**
     * ID of another tx that is depended
     */
    dependsOn: string | null;

    /**
     * Nonce value for various purposes.
     * Basic is to prevent replay attack by make transaction unique.
     * Every transaction with same chainTag, blockRef, ... must have different nonce.
     */
    nonce: string | number;

    /**
     * A reserved field intended for features use.
     *
     * In standard EVM transactions, this reserved field typically is not present.
     * However, it's been designed to cater to VIP-191, which deals with fee delegation.
     *
     * If the `features` within the `reserved` field is set as `1111...111`, it indicates that the transaction has been delegated.
     * The method to check if the transaction is delegated is:
     *
     * ```typescript
     * reserved.features & 1 === 1
     * ```
     *
     * @example
     *
     * 1.
     * ```typescript
     * feature = 111101;
     * isDelegated = (111101 & 111111) === 111101; // false (not delegated)
     * ```
     *
     * 2.
     * ```typescript
     * feature = 111111;
     * isDelegated = (111111 & 111111) === 111111; // true (delegated)
     * ```
     *
     * @remarks
     * For more information on the subject, refer to {@link https://github.com/vechain/VIPs/blob/master/vips/VIP-191.md | VIP-191}.
     */
    reserved?: {
        /**
         * Tx feature bits
         */
        features?: number;
        /**
         * Unused
         */
        unused?: Uint8Array[];
    };
}

/**
 * Represents an immutable transaction entity.
 */
declare class Transaction {
    /**
     * Represent the block reference length in bytes.
     */
    private static readonly BLOCK_REF_LENGTH;
    /**
     * A collection of constants used for gas calculations in transactions.
     *
     * Properties
     * - `TX_GAS` - The base gas cost for a transaction.
     * - `CLAUSE_GAS` - The gas cost for executing a clause in a transaction.
     * - `CLAUSE_GAS_CONTRACT_CREATION` - The gas cost for creating a contract via a clause.
     * - `ZERO_GAS_DATA` - The gas cost for transmitting zero bytes of data.
     * - `NON_ZERO_GAS_DATA` - The gas cost for transmitting non-zero bytes of data.
     */
    static readonly GAS_CONSTANTS: {
        TX_GAS: bigint;
        CLAUSE_GAS: bigint;
        CLAUSE_GAS_CONTRACT_CREATION: bigint;
        ZERO_GAS_DATA: bigint;
        NON_ZERO_GAS_DATA: bigint;
    };
    /**
     * RLP_FIELDS is an array of objects that defines the structure and encoding scheme
     * for various components in a transaction using Recursive Length Prefix (RLP) encoding.
     * Each object in the array represents a field in the transaction, specifying its name and kind.
     * The `kind` attribute is an instance of an RLP coder that determines how the field is encoded.
     *
     * Properties
     * - `chainTag` - Represent the id of the chain the transaction is sent to.
     * - `blockRef` - Represent the last block of the chain the transaction is sent to.
     * - `expiration` -  Represent the expiration date of the transaction.
     * - `clauses` - List of clause objects, each containing:
     *   - `to` - Represent the destination of the transaction.
     *   - `value` - Represent the 'wei' quantity (VET or VTHO) value the transaction is worth.
     *   - `data` - Represent the content of the transaction.
     * - `gasPriceCoef` - Represent the gas price coefficient of the transaction.
     * - `gas` - Represent the gas limit of the transaction.
     * - `dependsOn` - Represent the hash of the transaction the current transaction depends on.
     * - `nonce` - Represent the nonce of the transaction.
     * - `reserved` -  Reserved field.
     */
    private static readonly RLP_FIELDS;
    /**
     * Represent the Recursive Length Prefix (RLP) of the transaction features.
     *
     * Properties
     * - `name` - A string indicating the name of the field in the RLP structure.
     * - `kind` - RLP profile type.
     */
    private static readonly RLP_FEATURES;
    /**
     * Represents a Recursive Length Prefix (RLP) of the transaction signature.
     *
     * Properties
     * - `name` - A string indicating the name of the field in the RLP structure.
     * - `kind` - RLP profile type.
     */
    private static readonly RLP_SIGNATURE;
    /**
     * Represents a Recursive Length Prefix (RLP) of the signed transaction.
     *
     * Properties
     * - `name` - A string indicating the name of the field in the RLP structure.
     * - `kind` - RLP profile type.
     */
    private static readonly RLP_SIGNED_TRANSACTION_PROFILE;
    /**
     * Represents a Recursive Length Prefix (RLP) of the unsigned transaction.
     *
     * Properties
     * - `name` - A string indicating the name of the field in the RLP structure.
     * - `kind` - RLP profile type.
     */
    private static readonly RLP_UNSIGNED_TRANSACTION_PROFILE;
    /**
     * It represents the content of the transaction.
     */
    readonly body: TransactionBody;
    /**
     * It represents the signature of the transaction content.
     */
    readonly signature?: Uint8Array;
    /**
     * Creates a new instance of the class with the specified transaction body and optional signature.
     *
     * @param {TransactionBody} body The transaction body to be used.
     * @param {Uint8Array} [signature] The optional signature for the transaction.
     */
    protected constructor(body: TransactionBody, signature?: Uint8Array);
    /**
     * Get the delegator's address if the transaction is delegated.
     *
     * If the transaction is delegated and a signature is available, this method recovers
     * the delegator parameter from the signature and subsequently recovers the delegator's public key
     * to derive the delegator's address.
     *
     * @return {Address} The address of the delegator.
     * @throws {UnavailableTransactionField} If the transaction is delegated but the signature is missing.
     * @throws {NotDelegatedTransaction} If the transaction is not delegated.
     *
     * @remarks Security auditable method, depends on
     * - {@link Address.ofPublicKey};
     * - {@link Secp256k1.recover};
     * - {@link Transaction.getTransactionHash}.
     */
    get delegator(): Address;
    /**
     * Get the encoded bytes as a Uint8Array.
     * The encoding is determined by whether the data is signed.
     *
     * @return {Uint8Array} The encoded byte array.
     *
     * @see decode
     */
    get encoded(): Uint8Array;
    /**
     * Get transaction ID.
     *
     * The ID is the Blake2b256 hash of the transaction's signature
     * concatenated with the origin's address.
     * If the transaction is not signed,
     * it throws an UnavailableTransactionField error.
     *
     * @return {Blake2b256} The concatenated hash of the signature
     * and origin if the transaction is signed.
     * @throws {UnavailableTransactionField} If the transaction is not signed.
     *
     * @remarks Security auditable method, depends on
     * - {@link Blake2b256.of}
     */
    get id(): Blake2b256;
    /**
     * Return the intrinsic gas required for this transaction.
     *
     * @return {VTHO} The computed intrinsic gas for the transaction.
     */
    get intrinsicGas(): VTHO;
    /**
     * Returns `true` if the transaction is delegated, otherwise `false`.
     *
     * @return {boolean} `true` if the transaction is delegated,
     * otherwise `false`.
     */
    get isDelegated(): boolean;
    /**
     * Return `true` if the signature is defined and complete, otherwise `false`.
     *
     * @return {boolean} return `true` if the signature is defined and complete, otherwise `false`.
     *
     * @remarks Any delegated transaction signed with {@link signForDelegator}
     * but not yet signed with {@link signAsDelegator} is not signed.
     */
    get isSigned(): boolean;
    /**
     * Return the origin address of the transaction.
     *
     * The origin is determined by recovering the public key from the transaction's signature.
     *
     * @return {Address} The address derived from the public key of the transaction's signer.
     * @throws {UnavailableTransactionField} If the transaction is not signed, an exception is thrown indicating the absence of the origin field.
     *
     * @remarks Security auditable method, depends on
     * - {@link Address.ofPublicKey};
     * - {@link Secp256k1.recover}.
     */
    get origin(): Address;
    /**
     * Decodes a raw transaction byte array into a new Transaction object.
     *
     * @param {Uint8Array} rawTransaction - The raw transaction bytes to decode.
     * @param {boolean} isSigned - Flag indicating if the transaction is signed.
     * @return {Transaction} The decoded transaction object.
     *
     * @see encoded
     */
    static decode(rawTransaction: Uint8Array, isSigned: boolean): Transaction;
    /**
     * Computes the transaction hash, optionally incorporating a delegator's address.
     *
     * @param {Address} [delegator] - Optional delegator's address to include in the hash computation.
     * @return {Blake2b256} - The computed transaction hash.
     *
     * @remarks
     * `delegator` is used to sign a transaction on behalf of another account.
     *
     * @remarks Security auditable method, depends on
     * - {@link Blake2b256.of}.
     */
    getTransactionHash(delegator?: Address): Blake2b256;
    /**
     * Calculates the intrinsic gas required for the given transaction clauses.
     *
     * @param {TransactionClause[]} clauses - An array of transaction clauses to calculate the intrinsic gas for.
     * @return {VTHO} The total intrinsic gas required for the provided clauses.
     * @throws {InvalidDataType} If clauses have invalid data as invalid addresses.
     */
    static intrinsicGas(clauses: TransactionClause[]): VTHO;
    /**
     * Return `true` if the transaction body is valid, `false` otherwise.
     *
     * @param {TransactionBody} body - The transaction body to validate.
     * @return {boolean} `true` if the transaction body is valid, `false` otherwise.
     */
    static isValidBody(body: TransactionBody): boolean;
    /**
     * Creates a new Transaction instance if the provided body and optional
     * signature are valid.
     *
     * @param {TransactionBody} body - The transaction body to be validated.
     * @param {Uint8Array} [signature] - Optional signature to be validated.
     * @return {Transaction} A new Transaction instance if validation is successful.
     * @throws {InvalidSecp256k1Signature} If the provided signature is invalid.
     * @throws {InvalidTransactionField} If the provided body is invalid.
     */
    static of(body: TransactionBody, signature?: Uint8Array): Transaction;
    /**
     * Signs the transaction using the provided private key.
     *
     * @param {Uint8Array} signerPrivateKey - The private key used to sign the transaction.
     * @return {Transaction} The signed transaction.
     * @throws {InvalidTransactionField} If attempting to sign a delegated transaction.
     * @throws {InvalidSecp256k1PrivateKey} If the provided private key is not valid.
     *
     * @remarks Security auditable method, depends on
     * - {@link Secp256k1.isValidPrivateKey};
     * - {@link Secp256k1.sign}.
     */
    sign(signerPrivateKey: Uint8Array): Transaction;
    /**
     * Signs a transaction as a delegator using the provided private key. This is applicable only if the transaction
     * has been marked as delegated and already contains a signature that needs to be extended with a delegator signature.
     *
     * @param {Address} signer - The address of the signer for whom the transaction hash is generated.
     * @param {Uint8Array} delegatorPrivateKey - The private key of the delegator. Must be a valid secp256k1 key.
     *
     * @return {Transaction} - A new transaction object with the delegator's signature appended.
     *
     * @throws {InvalidSecp256k1PrivateKey} If the provided delegator private key is not valid.
     * @throws {InvalidTransactionField} If the transaction is unsigned or lacks a valid signature.
     * @throws {NotDelegatedTransaction} If the transaction is not set as delegated.
     *
     * @remarks Security auditable method, depends on
     * - {@link Secp256k1.isValidPrivateKey};
     * - {@link Secp256k1.sign}.
     */
    signAsDelegator(signer: Address, delegatorPrivateKey: Uint8Array): Transaction;
    /**
     * Signs a delegated transaction using the provided signer's private key,
     * call the {@link signAsDelegator} to complete the signature,
     * before such call {@link isDelegated} returns `true` but
     * {@link isSigned} returns `false`.
     *
     * @param signerPrivateKey The private key of the signer, represented as a Uint8Array. It must be a valid secp256k1 private key.
     * @return A new Transaction object with the signature applied, if the transaction is delegated and the private key is valid.
     * @throws NotDelegatedTransaction if the current transaction is not marked as delegated, instructing to use the regular sign method instead.
     * @throws InvalidSecp256k1PrivateKey if the provided signerPrivateKey is not a valid secp256k1 private key.
     *
     * @remarks Security auditable method, depends on
     * - {@link Secp256k1.isValidPrivateKey};
     * - {@link Secp256k1.sign}.
     */
    signForDelegator(signerPrivateKey: Uint8Array): Transaction;
    /**
     * Signs the transaction using both the signer and the delegator private keys.
     *
     * @param {Uint8Array} signerPrivateKey - The private key of the signer.
     * @param {Uint8Array} delegatorPrivateKey - The private key of the delegator.
     * @return {Transaction} A new transaction with the concatenated signatures
     * of the signer and the delegator.
     * @throws {InvalidSecp256k1PrivateKey} - If either the signer or delegator private key is invalid.
     * @throws {NotDelegatedTransaction} - If the transaction is not delegated.
     *
     * @remarks Security auditable method, depends on
     * - {@link Address.ofPublicKey}
     * - {@link Secp256k1.isValidPrivateKey};
     * - {@link Secp256k1.sign}.
     */
    signWithDelegator(signerPrivateKey: Uint8Array, delegatorPrivateKey: Uint8Array): Transaction;
    /**
     * Computes the amount of gas used for the given data.
     *
     * @param {string} data - The hexadecimal string data for which the gas usage is computed.
     * @return {bigint} The total gas used for the provided data.
     * @throws {InvalidDataType} If the data is not a valid hexadecimal string.
     *
     * @remarks gas value is expressed in {@link Units.wei} unit.
     */
    private static computeUsedGasFor;
    /**
     * Decodes the {@link TransactionBody.reserved} field from the given buffer array.
     *
     * @param {Buffer[]} reserved  - An array of Uint8Array objects representing the reserved field data.
     * @return {Object} An object containing the decoded features and any unused buffer data.
     * @return {number} [return.features] The decoded features from the reserved field.
     * @return {Buffer[]} [return.unused] An array of Buffer objects representing unused data, if any.
     * @throws {InvalidTransactionField} Thrown if the reserved field is not properly trimmed.
     */
    private static decodeReservedField;
    /**
     * Encodes the transaction body using RLP encoding.
     *
     * @param {boolean} isSigned - Indicates whether the transaction is signed.
     * @return {Uint8Array} The RLP encoded transaction body.
     *
     * @see encoded
     */
    private encode;
    /**
     * Encodes the given transaction body into a Uint8Array, depending on whether
     * the transaction is signed or not.
     *
     * @param body - The transaction object adhering to the RLPValidObject structure.
     * @param isSigned - A boolean indicating if the transaction is signed.
     * @return A Uint8Array representing the encoded transaction.
     *
     * @see encoded
     */
    private encodeBodyField;
    /**
     * Encodes the {@link TransactionBody.reserved} field data for a transaction.
     *
     * @return {Uint8Array[]} The encoded list of reserved features.
     * It removes any trailing unused features that have zero length from the list.
     *
     * @remarks The {@link TransactionBody.reserved} is optional, albeit
     * is required to perform RLP encoding.
     *
     * @see encode
     */
    private encodeReservedField;
    /**
     * Return `true` if the transaction is delegated, else `false`.
     *
     * @param {TransactionBody} body - The transaction body.
     * @return {boolean} `true` if the transaction is delegated, else `false`.
     */
    private static isDelegated;
    /**
     * Return Returns true if the signature is valid, otherwise false.
     *
     * @param {TransactionBody} body - The transaction body to be checked.
     * @param {Uint8Array} signature - The signature to validate.
     * @return {boolean} - Returns true if the signature is valid, otherwise false.
     */
    private static isSignatureValid;
}

/**
 * Constant representing the zero address in hexadecimal format
 */
declare const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
/**
 * VTHO token address (energy.sol smart contract address)
 */
declare const VTHO_ADDRESS = "0x0000000000000000000000000000456e65726779";
/**
 * Constant defining VeChain mainnet information
 */
declare const MAINNET_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining VeChain testnet information
 */
declare const TESTNET_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining VeChain solo network information
 */
declare const SOLO_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining VeChain mainnet and testnet network information
 */
declare const networkInfo: {
    mainnet: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
    testnet: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
    solo: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
};

/**
 * ABI of the ERC20 token standard.
 *
 * @see [EIP 20](https://eips.ethereum.org/EIPS/eip-20)
 */
declare const ERC20_ABI: readonly [{
    readonly inputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "allowance";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "needed";
        readonly type: "uint256";
    }];
    readonly name: "ERC20InsufficientAllowance";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "balance";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "needed";
        readonly type: "uint256";
    }];
    readonly name: "ERC20InsufficientBalance";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "approver";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidApprover";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidReceiver";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidSender";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidSpender";
    readonly type: "error";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }];
    readonly name: "allowance";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "decimals";
    readonly outputs: readonly [{
        readonly internalType: "uint8";
        readonly name: "";
        readonly type: "uint8";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "totalSupply";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "transfer";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];
/**
 * ABI of the ERC721 token standard.
 *
 * @see [EIP 721](https://eips.ethereum.org/EIPS/eip-721)
 */
declare const ERC721_ABI: readonly [{
    readonly inputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "ERC721IncorrectOwner";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ERC721InsufficientApproval";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "approver";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidApprover";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidOperator";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidOwner";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidReceiver";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidSender";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ERC721NonexistentToken";
    readonly type: "error";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "approved";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "ApprovalForAll";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "getApproved";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "isApprovedForAll";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "mintItem";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ownerOf";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "setApprovalForAll";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bytes4";
        readonly name: "interfaceId";
        readonly type: "bytes4";
    }];
    readonly name: "supportsInterface";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "tokenURI";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];
/**
 * ABI of the ERC1155 token standard.
 *
 * @see [EIP 1155](https://eips.ethereum.org/EIPS/eip-1155)
 */
declare const ERC1155_ABI: readonly [{
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "ApprovalForAll";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256[]";
        readonly name: "values";
        readonly type: "uint256[]";
    }];
    readonly name: "TransferBatch";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "TransferSingle";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "string";
        readonly name: "value";
        readonly type: "string";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "URI";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address[]";
        readonly name: "accounts";
        readonly type: "address[]";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }];
    readonly name: "balanceOfBatch";
    readonly outputs: readonly [{
        readonly internalType: "uint256[]";
        readonly name: "";
        readonly type: "uint256[]";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "isApprovedForAll";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "amounts";
        readonly type: "uint256[]";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeBatchTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "setApprovalForAll";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bytes4";
        readonly name: "interfaceId";
        readonly type: "bytes4";
    }];
    readonly name: "supportsInterface";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "uri";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];
/**
 * ABI of the VIP180 token standard.
 *
 * @see [VIP 180](https://github.com/vechain/VIPs/blob/master/vips/VIP-180.md)
 */
declare const VIP180_ABI: readonly [{
    readonly inputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "allowance";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "needed";
        readonly type: "uint256";
    }];
    readonly name: "ERC20InsufficientAllowance";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "balance";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "needed";
        readonly type: "uint256";
    }];
    readonly name: "ERC20InsufficientBalance";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "approver";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidApprover";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidReceiver";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidSender";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }];
    readonly name: "ERC20InvalidSpender";
    readonly type: "error";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }];
    readonly name: "allowance";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "decimals";
    readonly outputs: readonly [{
        readonly internalType: "uint8";
        readonly name: "";
        readonly type: "uint8";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "totalSupply";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "transfer";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];
/**
 * ABI of the VIP181 token standard.
 *
 * @see [VIP 181](https://github.com/vechain/VIPs/blob/master/vips/VIP-181.md)
 */
declare const VIP181_ABI: readonly [{
    readonly inputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "ERC721IncorrectOwner";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ERC721InsufficientApproval";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "approver";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidApprover";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidOperator";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidOwner";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidReceiver";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidSender";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ERC721NonexistentToken";
    readonly type: "error";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "approved";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "ApprovalForAll";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "getApproved";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "isApprovedForAll";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "mintItem";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ownerOf";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "setApprovalForAll";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bytes4";
        readonly name: "interfaceId";
        readonly type: "bytes4";
    }];
    readonly name: "supportsInterface";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "tokenURI";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];
/**
 * ABI of the VIP210 token standard.
 *
 * @see [VIP 210](https://github.com/vechain/VIPs/blob/master/vips/VIP-210.md)
 */
declare const VIP210_ABI: readonly [{
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "ApprovalForAll";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256[]";
        readonly name: "values";
        readonly type: "uint256[]";
    }];
    readonly name: "TransferBatch";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "TransferSingle";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "string";
        readonly name: "value";
        readonly type: "string";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "URI";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address[]";
        readonly name: "accounts";
        readonly type: "address[]";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }];
    readonly name: "balanceOfBatch";
    readonly outputs: readonly [{
        readonly internalType: "uint256[]";
        readonly name: "";
        readonly type: "uint256[]";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "isApprovedForAll";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "ids";
        readonly type: "uint256[]";
    }, {
        readonly internalType: "uint256[]";
        readonly name: "amounts";
        readonly type: "uint256[]";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeBatchTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "setApprovalForAll";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bytes4";
        readonly name: "interfaceId";
        readonly type: "bytes4";
    }];
    readonly name: "supportsInterface";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "id";
        readonly type: "uint256";
    }];
    readonly name: "uri";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];

/**
 * Create a Uint8Array filled with zero bytes of the specified size.
 *
 * @param {number} size - The size of the Uint8Array to create.
 * @returns {Uint8Array} - A Uint8Array filled with zero bytes.
 */
declare const ZERO_BYTES: (size: number) => Uint8Array;
/**
 * Regular expression for matching numeric values expressed as base 10 strings.
 *
 * The regular expression matches the following numeric patterns:
 *    - Whole numbers:
 *      - Positive whole numbers: 1, 2, 3, ...
 *      - Negative whole numbers: -1, -2, -3, ...
 *    - Decimal numbers:
 *      - Positive decimal numbers: 1.0, 2.5, 3.14, ...
 *      - Negative decimal numbers: -1.0, -2.5, -3.14, ...
 *      - Decimal numbers without whole part:
 *        - Positive decimal numbers: .1, .5, .75, ...
 *        - Negative decimal numbers: -.1, -.5, -.75, ...
 *
 * @constant {RegExp} NUMERIC_REGEX
 */
declare const NUMERIC_REGEX: RegExp;

declare const dataUtils: {
    decodeBytes32String: (hex: string) => string;
    encodeBytes32String: (value: string, zeroPadding?: "left" | "right") => string;
};

type core_ABI = ABI;
declare const core_ABI: typeof ABI;
type core_ABIContract<TAbi extends Abi> = ABIContract<TAbi>;
declare const core_ABIContract: typeof ABIContract;
type core_ABIEvent<TAbi extends Abi = Abi, TEventName extends ContractEventName<TAbi> = ContractEventName<TAbi>> = ABIEvent<TAbi, TEventName>;
declare const core_ABIEvent: typeof ABIEvent;
type core_ABIFunction<TAbi extends Abi = Abi, TFunctionName extends ContractFunctionName<TAbi> = ContractFunctionName<TAbi>> = ABIFunction<TAbi, TFunctionName>;
declare const core_ABIFunction: typeof ABIFunction;
type core_ABIItem = ABIItem;
declare const core_ABIItem: typeof ABIItem;
type core_Account = Account;
declare const core_Account: typeof Account;
type core_AccountType = AccountType;
type core_Address = Address;
declare const core_Address: typeof Address;
type core_Blake2b256 = Blake2b256;
declare const core_Blake2b256: typeof Blake2b256;
type core_BlockId = BlockId;
declare const core_BlockId: typeof BlockId;
type core_BlockRef = BlockRef;
declare const core_BlockRef: typeof BlockRef;
type core_BloomFilter = BloomFilter;
declare const core_BloomFilter: typeof BloomFilter;
type core_BufferKind = BufferKind;
declare const core_BufferKind: typeof BufferKind;
type core_BufferOutput = BufferOutput;
type core_Certificate = Certificate;
declare const core_Certificate: typeof Certificate;
type core_CertificateData = CertificateData;
type core_Clause = Clause;
declare const core_Clause: typeof Clause;
type core_ClauseOptions = ClauseOptions;
type core_Coin = Coin;
declare const core_Coin: typeof Coin;
type core_CompactFixedHexBlobKind = CompactFixedHexBlobKind;
declare const core_CompactFixedHexBlobKind: typeof CompactFixedHexBlobKind;
type core_Currency = Currency;
type core_DataOutput = DataOutput;
type core_DeployParams = DeployParams;
declare const core_ERC1155_ABI: typeof ERC1155_ABI;
declare const core_ERC20_ABI: typeof ERC20_ABI;
declare const core_ERC721_ABI: typeof ERC721_ABI;
type core_FixedHexBlobKind = FixedHexBlobKind;
declare const core_FixedHexBlobKind: typeof FixedHexBlobKind;
type core_FixedPointNumber = FixedPointNumber;
declare const core_FixedPointNumber: typeof FixedPointNumber;
type core_HDKey = HDKey;
declare const core_HDKey: typeof HDKey;
type core_Hex = Hex;
declare const core_Hex: typeof Hex;
type core_HexBlobKind = HexBlobKind;
declare const core_HexBlobKind: typeof HexBlobKind;
type core_HexInt = HexInt;
declare const core_HexInt: typeof HexInt;
type core_HexUInt = HexUInt;
declare const core_HexUInt: typeof HexUInt;
type core_Keccak256 = Keccak256;
declare const core_Keccak256: typeof Keccak256;
type core_Keystore = Keystore;
type core_KeystoreAccount = KeystoreAccount;
declare const core_MAINNET_NETWORK: typeof MAINNET_NETWORK;
type core_Mnemonic = Mnemonic;
declare const core_Mnemonic: typeof Mnemonic;
declare const core_NUMERIC_REGEX: typeof NUMERIC_REGEX;
type core_NumericKind = NumericKind;
declare const core_NumericKind: typeof NumericKind;
type core_OptionalFixedHexBlobKind = OptionalFixedHexBlobKind;
declare const core_OptionalFixedHexBlobKind: typeof OptionalFixedHexBlobKind;
type core_Quantity = Quantity;
declare const core_Quantity: typeof Quantity;
type core_RLP = RLP;
declare const core_RLP: typeof RLP;
type core_RLPInput = RLPInput;
type core_RLPOutput = RLPOutput;
type core_RLPProfile = RLPProfile;
type core_RLPProfiler = RLPProfiler;
declare const core_RLPProfiler: typeof RLPProfiler;
type core_RLPValidObject = RLPValidObject;
type core_RLPValueType = RLPValueType;
type core_Revision = Revision;
declare const core_Revision: typeof Revision;
declare const core_SOLO_NETWORK: typeof SOLO_NETWORK;
type core_ScalarKind = ScalarKind;
declare const core_ScalarKind: typeof ScalarKind;
type core_Secp256k1 = Secp256k1;
declare const core_Secp256k1: typeof Secp256k1;
type core_Sha256 = Sha256;
declare const core_Sha256: typeof Sha256;
declare const core_TESTNET_NETWORK: typeof TESTNET_NETWORK;
type core_ThorId = ThorId;
declare const core_ThorId: typeof ThorId;
type core_Transaction = Transaction;
declare const core_Transaction: typeof Transaction;
type core_TransactionBody = TransactionBody;
type core_TransactionClause = TransactionClause;
type core_Txt = Txt;
declare const core_Txt: typeof Txt;
declare const core_Units: typeof Units;
type core_VET = VET;
declare const core_VET: typeof VET;
declare const core_VIP180_ABI: typeof VIP180_ABI;
declare const core_VIP181_ABI: typeof VIP181_ABI;
declare const core_VIP210_ABI: typeof VIP210_ABI;
type core_VTHO = VTHO;
declare const core_VTHO: typeof VTHO;
declare const core_VTHO_ADDRESS: typeof VTHO_ADDRESS;
type core_VeChainDataModel<T> = VeChainDataModel<T>;
type core_WordListRandomGeneratorSizeInBytes = WordListRandomGeneratorSizeInBytes;
type core_WordlistSizeType = WordlistSizeType;
declare const core_ZERO_ADDRESS: typeof ZERO_ADDRESS;
declare const core_ZERO_BYTES: typeof ZERO_BYTES;
declare const core_assertCompactFixedHexBlobBuffer: typeof assertCompactFixedHexBlobBuffer;
declare const core_assertFixedHexBlobKindBuffer: typeof assertFixedHexBlobKindBuffer;
declare const core_assertFixedHexBlobKindData: typeof assertFixedHexBlobKindData;
declare const core_assertValidHexBlobKindData: typeof assertValidHexBlobKindData;
declare const core_assertValidNumericKindBuffer: typeof assertValidNumericKindBuffer;
declare const core_dataUtils: typeof dataUtils;
declare const core_decodeBufferToHexWithLeadingZeros: typeof decodeBufferToHexWithLeadingZeros;
declare const core_decodeBufferToNumberOrHex: typeof decodeBufferToNumberOrHex;
declare const core_encodeBigIntToBuffer: typeof encodeBigIntToBuffer;
declare const core_encodeCompactFixedHexBlob: typeof encodeCompactFixedHexBlob;
declare const core_keystore: typeof keystore;
declare const core_networkInfo: typeof networkInfo;
declare const core_validateNumericKindData: typeof validateNumericKindData;
declare namespace core {
  export { core_ABI as ABI, core_ABIContract as ABIContract, core_ABIEvent as ABIEvent, core_ABIFunction as ABIFunction, core_ABIItem as ABIItem, core_Account as Account, type core_AccountType as AccountType, core_Address as Address, core_Blake2b256 as Blake2b256, core_BlockId as BlockId, core_BlockRef as BlockRef, core_BloomFilter as BloomFilter, core_BufferKind as BufferKind, type core_BufferOutput as BufferOutput, core_Certificate as Certificate, type core_CertificateData as CertificateData, core_Clause as Clause, type core_ClauseOptions as ClauseOptions, core_Coin as Coin, core_CompactFixedHexBlobKind as CompactFixedHexBlobKind, type core_Currency as Currency, type core_DataOutput as DataOutput, type core_DeployParams as DeployParams, core_ERC1155_ABI as ERC1155_ABI, core_ERC20_ABI as ERC20_ABI, core_ERC721_ABI as ERC721_ABI, core_FixedHexBlobKind as FixedHexBlobKind, core_FixedPointNumber as FixedPointNumber, core_HDKey as HDKey, core_Hex as Hex, core_HexBlobKind as HexBlobKind, core_HexInt as HexInt, core_HexUInt as HexUInt, core_Keccak256 as Keccak256, type core_Keystore as Keystore, type core_KeystoreAccount as KeystoreAccount, core_MAINNET_NETWORK as MAINNET_NETWORK, core_Mnemonic as Mnemonic, core_NUMERIC_REGEX as NUMERIC_REGEX, core_NumericKind as NumericKind, core_OptionalFixedHexBlobKind as OptionalFixedHexBlobKind, core_Quantity as Quantity, core_RLP as RLP, type core_RLPInput as RLPInput, type core_RLPOutput as RLPOutput, type core_RLPProfile as RLPProfile, core_RLPProfiler as RLPProfiler, type core_RLPValidObject as RLPValidObject, type core_RLPValueType as RLPValueType, core_Revision as Revision, core_SOLO_NETWORK as SOLO_NETWORK, core_ScalarKind as ScalarKind, core_Secp256k1 as Secp256k1, core_Sha256 as Sha256, core_TESTNET_NETWORK as TESTNET_NETWORK, core_ThorId as ThorId, core_Transaction as Transaction, type core_TransactionBody as TransactionBody, type core_TransactionClause as TransactionClause, core_Txt as Txt, core_Units as Units, core_VET as VET, core_VIP180_ABI as VIP180_ABI, core_VIP181_ABI as VIP181_ABI, core_VIP210_ABI as VIP210_ABI, core_VTHO as VTHO, core_VTHO_ADDRESS as VTHO_ADDRESS, type core_VeChainDataModel as VeChainDataModel, type core_WordListRandomGeneratorSizeInBytes as WordListRandomGeneratorSizeInBytes, type core_WordlistSizeType as WordlistSizeType, core_ZERO_ADDRESS as ZERO_ADDRESS, core_ZERO_BYTES as ZERO_BYTES, core_assertCompactFixedHexBlobBuffer as assertCompactFixedHexBlobBuffer, core_assertFixedHexBlobKindBuffer as assertFixedHexBlobKindBuffer, core_assertFixedHexBlobKindData as assertFixedHexBlobKindData, core_assertValidHexBlobKindData as assertValidHexBlobKindData, core_assertValidNumericKindBuffer as assertValidNumericKindBuffer, core_dataUtils as dataUtils, core_decodeBufferToHexWithLeadingZeros as decodeBufferToHexWithLeadingZeros, core_decodeBufferToNumberOrHex as decodeBufferToNumberOrHex, core_encodeBigIntToBuffer as encodeBigIntToBuffer, core_encodeCompactFixedHexBlob as encodeCompactFixedHexBlob, core_keystore as keystore, core_networkInfo as networkInfo, core_validateNumericKindData as validateNumericKindData };
}

export { ABI, ABIContract, ABIEvent, ABIFunction, ABIItem, Account, type AccountType, Address, Blake2b256, BlockId, BlockRef, BloomFilter, BufferKind, type BufferOutput, Certificate, type CertificateData, Clause, type ClauseOptions, Coin, CompactFixedHexBlobKind, type Currency, type DataOutput, type DeployParams, ERC1155_ABI, ERC20_ABI, ERC721_ABI, FixedHexBlobKind, FixedPointNumber, HDKey, Hex, HexBlobKind, HexInt, HexUInt, Keccak256, type Keystore, type KeystoreAccount, MAINNET_NETWORK, Mnemonic, NUMERIC_REGEX, NumericKind, OptionalFixedHexBlobKind, Quantity, RLP, type RLPInput, type RLPOutput, type RLPProfile, RLPProfiler, type RLPValidObject, type RLPValueType, Revision, SOLO_NETWORK, ScalarKind, Secp256k1, Sha256, TESTNET_NETWORK, ThorId, Transaction, type TransactionBody, type TransactionClause, Txt, Units, VET, VIP180_ABI, VIP181_ABI, VIP210_ABI, VTHO, VTHO_ADDRESS, type VeChainDataModel, type WordListRandomGeneratorSizeInBytes, type WordlistSizeType, ZERO_ADDRESS, ZERO_BYTES, assertCompactFixedHexBlobBuffer, assertFixedHexBlobKindBuffer, assertFixedHexBlobKindData, assertValidHexBlobKindData, assertValidNumericKindBuffer, core, dataUtils, decodeBufferToHexWithLeadingZeros, decodeBufferToNumberOrHex, encodeBigIntToBuffer, encodeCompactFixedHexBlob, keystore, networkInfo, validateNumericKindData };
