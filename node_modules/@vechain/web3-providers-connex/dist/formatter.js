'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Formatter = void 0;
const utils_1 = require("./utils");
const error_1 = require("./error");
const common_1 = require("./common");
const eip1193_1 = require("./eip1193");
class Formatter {
    _connex;
    _inputFormatters = {};
    _ifSetNet;
    constructor(connex, ifSetNet) {
        this._connex = connex;
        this._ifSetNet = ifSetNet;
        this._inputFormatters['eth_getBlockByNumber'] = this._getBlockByNumber;
        this._inputFormatters['eth_getBlockByHash'] = this._getBlockByHash;
        this._inputFormatters['eth_getBalance'] = this._getBalance;
        this._inputFormatters['eth_getCode'] = this._getCode;
        this._inputFormatters['eth_getStorageAt'] = this._getStorageAt;
        this._inputFormatters['eth_sendTransaction'] = this._sendTransaction;
        this._inputFormatters['eth_call'] = this._call;
        this._inputFormatters['eth_estimateGas'] = this._estimateGas;
        this._inputFormatters['eth_getLogs'] = this._getLogs;
        this._inputFormatters['eth_subscribe'] = this._subscribe;
        this._inputFormatters['eth_sendRawTransaction'] = this._sendRawTransaction;
        this._inputFormatters['debug_traceCall'] = this._traceCall;
    }
    formatInput = (method, params) => {
        const inputFormatter = this._inputFormatters[method];
        if (!inputFormatter) {
            return params ? params : [];
        }
        if (!params) {
            const msg = 'Parameters missing';
            throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
        }
        return inputFormatter(params);
    };
    _getBlockByNumber = (params) => {
        const num = (0, utils_1.parseBlockNumber)(params[0]);
        if (num === null) {
            const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getBlockByNumber', 'blockNumber');
            throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
        }
        return [num];
    };
    _getBlockByHash = (params) => {
        const num = params[0];
        if (num !== (0, utils_1.parseBlockNumber)(num)) {
            const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getBlockByNumber', 'blockHash');
            throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
        }
        return [num];
    };
    _getBalance = (params) => {
        let [addr, revision = 'latest'] = params;
        if (!this._ifSetNet) {
            if (params.length == 2 &&
                !(typeof revision === 'string' && revision === 'latest')) {
                const msg = error_1.ErrMsg.MethodParamNotSupported('eth_getBalance', 2);
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
        }
        else if (typeof revision !== 'number') {
            revision = (0, utils_1.parseBlockNumber)(revision);
            if (revision === null) {
                const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getBalance', 'revision');
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
        }
        return revision ? [addr, revision] : [addr];
    };
    _getCode = (params) => {
        let [addr, revision = 'latest'] = params;
        if (!this._ifSetNet) {
            if (params.length >= 2 &&
                !(typeof revision === 'string' && revision === 'latest')) {
                const msg = error_1.ErrMsg.MethodParamNotSupported('eth_getCode', 2);
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
        }
        else if (typeof revision !== 'number') {
            revision = (0, utils_1.parseBlockNumber)(revision);
            if (revision === null) {
                const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getCode', 'revision');
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
        }
        return revision ? [addr, revision] : [addr];
    };
    _getStorageAt = (params) => {
        let [addr, key, revision = 'latest'] = params;
        if (!this._ifSetNet) {
            if (params.length >= 3 &&
                !(typeof revision === 'string' && revision === 'latest')) {
                const msg = error_1.ErrMsg.MethodParamNotSupported('eth_getStorageAt', 3);
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
        }
        else if (typeof revision !== 'number') {
            revision = (0, utils_1.parseBlockNumber)(revision);
            if (revision === null) {
                const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getStorageAt', 'revision');
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
        }
        key = (0, utils_1.toBytes32)(key);
        return revision ? [addr, key, revision] : [addr, key];
    };
    _sendTransaction = (params) => {
        const o1 = params[0];
        let data = '0x';
        if (o1.data) {
            data = o1.data;
        }
        if (o1.input) {
            data = o1.input;
        }
        const o2 = {
            clauses: [{
                    to: o1.to || null,
                    value: o1.value ? (0, utils_1.toHex)(o1.value) : '0x0',
                    data: data,
                }],
            gas: o1.gas ? (0, utils_1.hexToNumber)(o1.gas) : undefined,
            gasPrice: o1.gasPrice,
            caller: o1.from,
        };
        return [o2, params[1]];
    };
    _call = (params) => {
        let [callObj, revision = 'latest'] = params;
        if (!this._ifSetNet) {
            if (params.length >= 2 &&
                !(typeof revision === 'string' && revision === 'latest')) {
                const msg = error_1.ErrMsg.MethodParamNotSupported('eth_call', 2);
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
        }
        else if (typeof revision !== 'number') {
            revision = (0, utils_1.parseBlockNumber)(revision);
            if (revision === null) {
                const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_call', 'revision');
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
        }
        callObj = this._sendTransaction([callObj])[0];
        return revision ? [callObj, revision] : [callObj];
    };
    _estimateGas = (params) => {
        return this._sendTransaction(params);
    };
    _getLogs = (params) => {
        const args = params[0];
        let fromBlock, toBlock;
        if (!args.fromBlock) {
            fromBlock = this._connex.thor.status.head.number; // fromBlock default set to latest
        }
        else {
            let test = (0, utils_1.parseBlockNumber)(args.fromBlock);
            if (test === undefined) {
                test = this._connex.thor.status.head.number;
            }
            else if (typeof test !== 'number') {
                const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getLogs', 'options.fromBlock');
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
            fromBlock = test;
        }
        if (!args.toBlock) {
            toBlock = this._connex.thor.status.head.number; // toBlock default set to latest
        }
        else {
            let test = (0, utils_1.parseBlockNumber)(args.toBlock);
            if (test === undefined) {
                test = this._connex.thor.status.head.number;
            }
            else if (typeof test !== 'number') {
                const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getLogs', 'options.toBlock');
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
            toBlock = test;
            if (fromBlock > toBlock) {
                fromBlock = toBlock;
            }
        }
        const out = {
            range: {
                unit: 'block',
                from: fromBlock,
                to: toBlock,
            },
            criteria: (0, utils_1.toFilterCriteria)(args),
        };
        return [out];
    };
    _traceCall = (params) => {
        // trace call needs net, bypass if net not set
        if (!this._ifSetNet) {
            return params;
        }
        let [callObj, revision = 'latest', opt] = params;
        revision = (0, utils_1.parseBlockNumber)(revision);
        if (revision === null) {
            const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('debug_traceCall', 'revision');
            throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
        }
        const arg = {
            to: callObj.to || null,
            value: callObj.value || '0x0',
            data: callObj.data || '0x',
            gas: callObj.gas ? (0, utils_1.hexToNumber)(callObj.gas) : undefined,
            gasPrice: callObj.gasPrice,
            caller: callObj.from,
        };
        return [arg, revision, opt];
    };
    _subscribe = (params) => {
        const name = params[0];
        switch (name) {
            case 'newHeads':
                return ['newHeads'];
            case 'logs':
                return ['logs', (0, utils_1.toFilterCriteria)(params[1])];
            default:
                const msg = error_1.ErrMsg.InvalidSubscriptionName(name);
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
        }
    };
    _sendRawTransaction = (params) => {
        const raw = params[0];
        if (!(0, utils_1.isHexStrict)(raw)) {
            const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_sendRawTransaction', 'raw');
            throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
        }
        return [raw];
    };
    outputReceiptFormatter = (receipt) => {
        const logs = (receipt.outputs.length > 0 && receipt.outputs[0].events.length > 0) ?
            receipt.outputs[0].events.map((event, index) => {
                return {
                    blockHash: receipt.meta.blockID,
                    blockNumber: (0, utils_1.toHex)(receipt.meta.blockNumber),
                    transactionHash: receipt.meta.txID,
                    address: event.address,
                    topics: event.topics.map((x) => x),
                    data: event.data,
                    removed: false,
                    transactionIndex: receipt.transactionIndex,
                    logIndex: receipt.logInds[index],
                };
            }) : [];
        return {
            status: !receipt.reverted ? '0x1' : '0x0',
            blockHash: receipt.meta.blockID,
            blockNumber: (0, utils_1.toHex)(receipt.meta.blockNumber),
            transactionHash: receipt.meta.txID,
            gasUsed: (0, utils_1.toHex)(receipt.gasUsed),
            transactionIndex: receipt.transactionIndex,
            from: receipt.from,
            to: receipt.to,
            cumulativeGasUsed: '0x0',
            logsBloom: common_1.zeroBytes256,
            contractAddress: (receipt.outputs.length && receipt.outputs[0].contractAddress) ? receipt.outputs[0].contractAddress : null,
            logs: logs,
        };
    };
    outputBlockFormatter = (b) => {
        return {
            hash: b.id,
            parentHash: b.parentID,
            number: (0, utils_1.toHex)(b.number),
            size: (0, utils_1.toHex)(b.size),
            stateRoot: b.stateRoot,
            receiptsRoot: b.receiptsRoot,
            transactionsRoot: b.txsRoot,
            timestamp: (0, utils_1.toHex)(b.timestamp),
            gasLimit: (0, utils_1.toHex)(b.gasLimit),
            gasUsed: (0, utils_1.toHex)(b.gasUsed),
            transactions: b.transactions,
            miner: b.signer,
            // incompatible fields
            difficulty: '0x0',
            totalDifficulty: '0x0',
            uncles: [],
            sha3Uncles: common_1.zeroBytes32,
            nonce: common_1.zeroBytes8,
            logsBloom: common_1.zeroBytes256,
            extraData: '0x',
        };
    };
    outputTransactionFormatter = (tx) => {
        return {
            hash: tx.id,
            blockNumber: (0, utils_1.toHex)(tx.meta.blockNumber),
            blockHash: tx.meta.blockID,
            from: tx.origin,
            to: tx.clauses[0].to,
            input: tx.clauses[0].data,
            value: tx.clauses[0].value,
            gas: (0, utils_1.toHex)(tx.gas),
            transactionIndex: tx.transactionIndex,
            // incompatible fields
            nonce: '0x0',
            gasPrice: '0x0',
            signature: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        };
    };
    outputLogsFormatter = (ret) => {
        return ret.logs.map((log, i) => {
            return {
                address: log.address,
                topics: log.topics,
                data: log.data,
                blockHash: log.meta.blockID,
                blockNumber: (0, utils_1.toHex)(log.meta.blockNumber),
                transactionHash: log.meta.txID,
                removed: false,
                transactionIndex: ret.txInds[i],
                logIndex: ret.logInds[i],
            };
        });
    };
    outputHeaderFormatter = (b) => {
        return {
            hash: b.id,
            parentHash: b.parentID,
            number: (0, utils_1.toHex)(b.number),
            stateRoot: b.stateRoot,
            receiptsRoot: b.receiptsRoot,
            transactionsRoot: b.txsRoot,
            timestamp: (0, utils_1.toHex)(b.timestamp),
            gasLimit: (0, utils_1.toHex)(b.gasLimit),
            gasUsed: (0, utils_1.toHex)(b.gasUsed),
            miner: b.signer,
            // incompatible fields
            sha3Uncles: common_1.zeroBytes32,
            nonce: common_1.zeroBytes8,
            logsBloom: common_1.zeroBytes256,
            extraData: '0x',
        };
    };
}
exports.Formatter = Formatter;
//# sourceMappingURL=formatter.js.map