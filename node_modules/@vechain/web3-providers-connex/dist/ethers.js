'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.modifyProvider = exports.modifyFactory = void 0;
const ethers_1 = require("ethers");
const modifyFactory = (factory) => {
    factory.deploy = async function (...args) {
        const tx = await this.getDeployTransaction(...args);
        (0, ethers_1.assert)(this.runner && typeof (this.runner.sendTransaction) === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
            operation: "sendTransaction"
        });
        const sentTx = await this.runner.sendTransaction(tx);
        // Patch the original code (Line 112 in contract/factory.ts): 
        //
        //    const address = getCreateAddress(sentTx);
        //
        let address = null;
        let count = 0; // try 5 times
        while (count < 5) {
            if (!this.runner.provider) {
                throw new Error("no provider");
            }
            const receipt = await this.runner.provider.getTransactionReceipt(sentTx.hash);
            if (receipt) {
                address = receipt.contractAddress;
                break;
            }
            count++;
        }
        // End of the patch
        return new ethers_1.BaseContract(address, this.interface, this.runner, sentTx);
    };
    return factory;
};
exports.modifyFactory = modifyFactory;
const modifyProvider = (provider) => {
    provider._wrapTransactionResponse = function (tx, network) {
        return new ethers_1.TransactionResponse(formatTransactionResponse(tx), this);
    };
    return provider;
};
exports.modifyProvider = modifyProvider;
function formatTransactionResponse(value) {
    const BN_0 = BigInt(0);
    // Some clients (TestRPC) do strange things like return 0x0 for the
    // 0 address; correct this to be a real address
    if (value.to && (0, ethers_1.getBigInt)(value.to) === BN_0) {
        value.to = "0x0000000000000000000000000000000000000000";
    }
    const result = object({
        hash: formatHash,
        type: (value) => {
            if (value === "0x" || value == null) {
                return 0;
            }
            return (0, ethers_1.getNumber)(value);
        },
        accessList: allowNull(ethers_1.accessListify, null),
        blockHash: allowNull(formatHash, null),
        blockNumber: allowNull(ethers_1.getNumber, null),
        transactionIndex: allowNull(ethers_1.getNumber, null),
        //confirmations: allowNull(getNumber, null),
        from: ethers_1.getAddress,
        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
        gasPrice: allowNull(ethers_1.getBigInt),
        maxPriorityFeePerGas: allowNull(ethers_1.getBigInt),
        maxFeePerGas: allowNull(ethers_1.getBigInt),
        gasLimit: ethers_1.getBigInt,
        to: allowNull(ethers_1.getAddress, null),
        value: ethers_1.getBigInt,
        nonce: ethers_1.getNumber,
        data: formatData,
        creates: allowNull(ethers_1.getAddress, null),
        chainId: allowNull(ethers_1.getBigInt, null)
    }, {
        data: ["input"],
        gasLimit: ["gas"]
    })(value);
    // Remove the original code (Line 227-229 in providers/format.ts) due to 
    // the incompactibility of fn getCreateAddress:
    //
    //    // If to and creates are empty, populate the creates from the value
    //    if (result.to == null && result.creates == null) {
    //        result.creates = getCreateAddress(result)
    //    }
    // @TODO: Check fee data
    // Add an access list to supported transaction types
    if ((value.type === 1 || value.type === 2) && value.accessList == null) {
        result.accessList = [];
    }
    // Remove the original code (Line 239-243 in providers/format.ts)
    //
    //    // Compute the signature
    //    if (value.signature) {
    //        result.signature = Signature.from(value.signature);
    //    } else {
    //        result.signature = Signature.from(value);
    //    }
    // Remove the original code (Line 246-249 in providers/format.ts):
    // 
    //    // Some backends omit ChainId on legacy transactions, but we can compute it
    //    if (result.chainId == null) {
    //        const chainId = result.signature.legacyChainId;
    //        if (chainId != null) { result.chainId = chainId; }
    //    }
    // 0x0000... should actually be null
    if (result.blockHash && (0, ethers_1.getBigInt)(result.blockHash) === BN_0) {
        result.blockHash = null;
    }
    return result;
}
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (typeof (length) === "number" && value.length !== 2 + 2 * length) {
        return false;
    }
    if (length === true && (value.length % 2) !== 0) {
        return false;
    }
    return true;
}
function assertArgument(check, message, name, value) {
    (0, ethers_1.assert)(check, message, "INVALID_ARGUMENT", { argument: name, value: value });
}
function formatHash(value) {
    assertArgument(isHexString(value, 32), "invalid hash", "value", value);
    return value;
}
function object(format, altNames) {
    return ((value) => {
        const result = {};
        for (const key in format) {
            let srcKey = key;
            if (altNames && key in altNames && !(srcKey in value)) {
                for (const altKey of altNames[key]) {
                    if (altKey in value) {
                        srcKey = altKey;
                        break;
                    }
                }
            }
            try {
                const nv = format[key](value[srcKey]);
                if (nv !== undefined) {
                    result[key] = nv;
                }
            }
            catch (error) {
                const message = (error instanceof Error) ? error.message : "not-an-error";
                (0, ethers_1.assert)(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
            }
        }
        return result;
    });
}
function allowNull(format, nullValue) {
    return (function (value) {
        if (value == null) {
            return nullValue;
        }
        return format(value);
    });
}
function formatData(value) {
    assertArgument(isHexString(value, true), "invalid data", "value", value);
    return value;
}
//# sourceMappingURL=ethers.js.map