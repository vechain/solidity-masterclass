/// <reference types="node" />
/// <reference types="@vechain/connex-types" />
import { RequestArguments } from "./eip1193";
export type ZeroBytes8 = '0x0000000000000000';
export type ZeroBytes20 = '0x0000000000000000000000000000000000000000';
export type ZeroBytes32 = '0x0000000000000000000000000000000000000000000000000000000000000000';
export type ZeroBytes256 = '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
export interface Net {
    /** base URL */
    readonly baseURL: string;
    /**
     * perform http request
     * @param method 'GET' or 'POST'
     * @param path path to access
     * @param params additional params
     * @returns response body, JSON decoded
     */
    http(method: 'GET' | 'POST', path: string, params?: Net.Params): Promise<any>;
    /**
     * open websocket reader on path
     * @param path
     */
    openWebSocketReader(path: string): Net.WebSocketReader;
}
export declare namespace Net {
    /** http request params */
    interface Params {
        query?: Record<string, string>;
        body?: any;
        headers?: Record<string, string>;
        validateResponseHeader?: (headers: Record<string, string>) => void;
    }
    /** websocket reader */
    interface WebSocketReader {
        /** read data */
        read(): Promise<any>;
        close(): void;
    }
}
export interface Wallet {
    /** list all keys */
    readonly list: Wallet.Key[];
}
export declare namespace Wallet {
    /** describes an operational key */
    interface Key {
        /** address derived from key */
        address: string;
        /**
         * sign message hash
         * @param msgHash message hash
         * @returns signature
         */
        sign(msgHash: Buffer): Promise<Buffer>;
    }
}
export type ExplainArg = {
    clauses: Array<{
        to: string | null;
        value: string;
        data: string;
    }>;
    caller?: string;
    gas?: number;
    gasPrice?: string;
};
export interface AbstractProvider {
    sendAsync(payload: JsonRpcPayload, callback: (error: Error | null, result?: JsonRpcResponse) => void): void;
    send?(payload: JsonRpcPayload, callback: (error: Error | null, result?: JsonRpcResponse) => void): void;
    request?(args: RequestArguments): Promise<any>;
    connected?: boolean;
}
export interface JsonRpcPayload extends RequestArguments {
    jsonrpc: string;
    id?: number | string;
}
export interface JsonRpcResponse {
    id: number;
    jsonrpc: string;
    result?: any;
    error?: any;
}
export interface RetBlock extends RetHeader {
    size: string;
    transactions: string[];
    difficulty: '0x0';
    totalDifficulty: '0x0';
    uncles: [];
}
export interface RetHeader {
    number: string;
    hash: string;
    parentHash: string;
    transactionsRoot: string;
    stateRoot: string;
    receiptsRoot: string;
    miner: string;
    gasLimit: string;
    gasUsed: string;
    timestamp: string;
    sha3Uncles: ZeroBytes32;
    nonce: ZeroBytes8;
    logsBloom: ZeroBytes256;
    extraData: '0x';
}
export interface RetTransaction {
    hash: string;
    blockHash: string;
    blockNumber: string;
    from: string;
    to: string | null;
    value: string;
    gas: string;
    input: string;
    transactionIndex: string;
    nonce: '0x0';
    gasPrice: '0x0';
    signature: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
}
export interface RetReceipt {
    transactionHash: string;
    blockHash: string;
    blockNumber: string;
    contractAddress: string | null;
    gasUsed: string;
    transactionIndex: string;
    from: string;
    to: string | null;
    status: '0x0' | '0x1';
    logsBloom: ZeroBytes256;
    cumulativeGasUsed: '0x0';
    logs: RetLog[];
}
export interface RetLog {
    address: string;
    data: string;
    topics: string[];
    transactionHash: string;
    blockHash: string;
    blockNumber: string;
    removed: false;
    logIndex: string;
    transactionIndex: string;
}
export type TxObj = {
    to?: string;
    from?: string;
    value?: string;
    data?: string;
    gas?: string;
    gasPrice?: string;
    input?: string;
};
export type FilterOpts = {
    address?: string | string[];
    fromBlock?: string;
    toBlock?: string;
    topics?: string[] | string[][];
};
export type ConvertedFilterOpts = {
    range: Connex.Thor.Filter.Range;
    criteria: Connex.Thor.Filter.Criteria<'event'>[];
};
export type DelegateOpt = {
    url: string;
    signer?: string;
};
export interface TracerOption {
    name: string;
    config: object;
}
export interface TraceClauseOption extends TracerOption {
    target: string;
}
export interface TraceCallOption extends TracerOption {
    to: string | null;
    value: string;
    data: string;
    caller?: string;
    gas?: number;
    gasPrice?: string;
}
