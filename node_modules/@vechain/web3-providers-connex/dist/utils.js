'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrMsg = exports.decodeRevertReason = exports.signTransaction = exports.wait = exports.toFilterCriteria = exports.isHexStrict = exports.randAddr = exports.toHex = exports.hexToNumber = exports.toBytes32 = exports.parseBlockNumber = exports.toSubscription = void 0;
const crypto_1 = require("crypto");
const web3_utils_1 = __importDefault(require("web3-utils"));
const thor_devkit_1 = require("thor-devkit");
const toSubscription = function (ret, id) {
    return {
        type: 'eth_subscription',
        data: {
            subscription: id,
            result: ret,
        }
    };
};
exports.toSubscription = toSubscription;
/**
 * Convert the input into either block id or block number compatible with connex.thor.block()
 * @param {hex | 'earliest' | 'latest' } input
 * @returns {string | number | null | undefined} Return null not recognized and undefined if input === 'latest'
 */
function parseBlockNumber(input) {
    // Return block id;
    if (web3_utils_1.default.isHexStrict(input) && input.length == 66) {
        return input;
    }
    // Convert block number;
    if (web3_utils_1.default.isHexStrict(input)) {
        return web3_utils_1.default.hexToNumber(input);
    }
    else if (input === 'earliest') {
        return 0;
    }
    else if (input === 'latest') {
        return undefined;
    }
    return null;
}
exports.parseBlockNumber = parseBlockNumber;
function toBytes32(hex) {
    return web3_utils_1.default.padLeft(hex, 64);
}
exports.toBytes32 = toBytes32;
function hexToNumber(hex) {
    const n = web3_utils_1.default.hexToNumber(hex);
    if (typeof n === 'number') {
        return n;
    }
    return parseInt(n);
}
exports.hexToNumber = hexToNumber;
function toHex(value) {
    return web3_utils_1.default.toHex(value);
}
exports.toHex = toHex;
function randAddr() {
    return '0x' + (0, crypto_1.randomBytes)(20).toString('hex');
}
exports.randAddr = randAddr;
function isHexStrict(hex) {
    return web3_utils_1.default.isHexStrict(hex);
}
exports.isHexStrict = isHexStrict;
/**
 * Decompose (T | T[] | null)[] into (T | null)[].
 * E.g., [1, [2, 3], null, 4] => [[1 , 2, null, 4], [1, 3, null, 4]]
 */
function decompose(x) {
    let y = [];
    // Create instances for the first element
    if (Array.isArray(x[0])) {
        x[0].forEach(x => y.push([x, null, null, null]));
    }
    else {
        y.push([x[0], null, null, null]);
    }
    for (let i = 1; i < x.length; i++) {
        const xi = x[i];
        if (xi === null) {
            continue;
        }
        if (!Array.isArray(xi)) {
            // Update the i'th element for the existing instances
            y.forEach(e => e[i] = xi);
            continue;
        }
        // Update the i'th row of y with value xi[0]
        y.forEach(e => e[i] = xi[0]);
        // make a copy of y
        const cpy = y.map(e => e.map(e => e));
        for (let j = 1; j < xi.length; j++) {
            // Duplicate the current copy and 
            // assign a new value for the i'th element
            const yy = cpy.map(e => e.map(e => e));
            yy.forEach(e => e[i] = xi[j]);
            // Attach the new instances
            y = y.concat(yy);
        }
    }
    return y;
}
function toFilterCriteria(args) {
    const setCriteria = (address, topics) => {
        const c = {};
        if (address) {
            c.address = address;
        }
        ;
        if (topics) {
            if (topics[0]) {
                c.topic0 = topics[0];
            }
            if (topics[1]) {
                c.topic1 = topics[1];
            }
            if (topics[2]) {
                c.topic2 = topics[2];
            }
            if (topics[3]) {
                c.topic3 = topics[3];
            }
        }
        return c;
    };
    let ret = [];
    // Address and topics both unavailable
    if (!args.address && !args.topics) {
        return [];
    }
    // Only address available
    if (!args.topics) {
        if (Array.isArray(args.address)) {
            args.address.forEach(addr => ret.push(setCriteria(addr)));
        }
        else {
            ret.push(setCriteria(args.address));
        }
        return ret;
    }
    // Decompose topics
    let topics = decompose(args.topics);
    let address;
    if (!args.address) {
        address = [undefined];
    }
    else if (!Array.isArray(args.address)) {
        address = [args.address];
    }
    else {
        address = args.address;
    }
    address.forEach(addr => {
        topics.forEach(topics => {
            ret.push(setCriteria(addr, topics));
        });
    });
    return ret;
}
exports.toFilterCriteria = toFilterCriteria;
const wait = (ms) => {
    return new Promise(resolve => {
        setTimeout(() => resolve(true), ms);
    });
};
exports.wait = wait;
/** params for tx construction */
const txParams = {
    expiration: 18,
    gasPriceCoef: 0
};
const signTransaction = async (ethTx, key, provider) => {
    const clauses = [{
            to: ethTx.to || null,
            value: ethTx.value ? toHex(ethTx.value) : '0x0',
            data: ethTx.data || '0x'
        }];
    const gas = ethTx.gas || await provider.request({
        method: 'eth_estimateGas',
        params: [ethTx]
    });
    const chainId = provider.chainTag;
    const best = await provider.request({
        method: 'eth_getBlockByNumber',
        params: ['latest']
    });
    const txBody = {
        chainTag: chainId,
        blockRef: best.hash.slice(0, 18),
        expiration: txParams.expiration,
        clauses,
        gasPriceCoef: txParams.gasPriceCoef,
        gas,
        dependsOn: null,
        nonce: '0x' + (0, crypto_1.randomBytes)(8).toString('hex')
    };
    const tx = new thor_devkit_1.Transaction(txBody);
    tx.signature = await key.sign(tx.signingHash());
    return '0x' + tx.encode().toString('hex');
};
exports.signTransaction = signTransaction;
function decodeRevertReason(data) {
    const errSig = '0x08c379a0';
    try {
        if (data.startsWith(errSig)) {
            return thor_devkit_1.abi.decodeParameter('string', '0x' + data.slice(errSig.length));
        }
        return null;
    }
    catch {
        return null;
    }
}
exports.decodeRevertReason = decodeRevertReason;
function getErrMsg(err) {
    let msg = '';
    if (typeof err === 'string') {
        msg = err;
    }
    else if (err.message) {
        msg = err.message;
    }
    return msg;
}
exports.getErrMsg = getErrMsg;
//# sourceMappingURL=utils.js.map