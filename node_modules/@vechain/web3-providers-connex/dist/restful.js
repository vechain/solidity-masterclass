'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Restful = void 0;
const error_1 = require("./error");
const utils_1 = require("./utils");
const eip1193_1 = require("./eip1193");
class Restful {
    _net;
    _genesisId;
    constructor(net, genesisId) {
        this._net = net;
        this._genesisId = genesisId;
    }
    get _headerValidator() {
        return (headers) => {
            const xgid = headers['x-genesis-id'];
            if (xgid && xgid !== this._genesisId) {
                throw new Error(`responded 'x-genesis-id' not matched`);
            }
        };
    }
    sendRawTransaction = async (raw) => {
        try {
            const resp = await this._net.http("POST", "transactions", {
                body: { raw: raw },
                validateResponseHeader: this._headerValidator
            });
            return resp.id;
        }
        catch (err) {
            return Promise.reject({
                code: error_1.ErrCode.Default,
                message: (0, utils_1.getErrMsg)(err)
            });
        }
    };
    getCode = async (addr, revision) => {
        try {
            const httpParams = {
                validateResponseHeader: this._headerValidator
            };
            if (revision) {
                httpParams.query = { "revision": revision };
            }
            const code = await this._net.http("GET", `accounts/${addr}/code`, httpParams);
            return code.code;
        }
        catch (err) {
            return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
        }
    };
    getBalance = async (addr, revision) => {
        try {
            const httpParams = {
                validateResponseHeader: this._headerValidator
            };
            if (revision) {
                httpParams.query = { "revision": revision };
            }
            const acc = await this._net.http("GET", `accounts/${addr}`, httpParams);
            return acc.balance;
        }
        catch (err) {
            return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
        }
    };
    getStorageAt = async (addr, key, revision) => {
        try {
            const httpParams = {
                validateResponseHeader: this._headerValidator
            };
            if (revision) {
                httpParams.query = { "revision": revision };
            }
            const storage = await this._net.http("GET", `accounts/${addr}/storage/${key}`, httpParams);
            return storage.value;
        }
        catch (err) {
            return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
        }
    };
    call = async (callObj, revision) => {
        try {
            const httpParams = {
                body: callObj,
                validateResponseHeader: this._headerValidator
            };
            if (revision) {
                httpParams.query = { "revision": revision };
            }
            const outputs = await this._net.http("POST", `accounts/*`, httpParams);
            const output = outputs[0];
            if (output.reverted) {
                if (output.vmError === 'execution reverted') {
                    const reason = (0, utils_1.decodeRevertReason)(output.data);
                    return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.Default, reason ? `execution reverted: ${reason}` : output.vmError, output.data));
                }
                else {
                    return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.Default, output.vmError));
                }
            }
            return output.data;
        }
        catch (err) {
            return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
        }
    };
    traceClause = async (opts) => {
        try {
            const httpParams = {
                body: opts,
                validateResponseHeader: this._headerValidator
            };
            const ret = await this._net.http("POST", 'debug/tracers', httpParams);
            return ret;
        }
        catch (err) {
            return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
        }
    };
    traceCall = async (opts, revision) => {
        try {
            const httpParams = {
                body: opts,
                validateResponseHeader: this._headerValidator
            };
            if (revision) {
                httpParams.query = { "revision": revision };
            }
            const ret = await this._net.http("POST", 'debug/tracers/call', httpParams);
            return ret;
        }
        catch (err) {
            return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
        }
    };
}
exports.Restful = Restful;
//# sourceMappingURL=restful.js.map