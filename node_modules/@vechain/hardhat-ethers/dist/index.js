"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const hardhat_vechain_1 = require("@vechain/hardhat-vechain");
require("./type-extensions");
const helpers_1 = require("@nomicfoundation/hardhat-ethers/internal/helpers");
const ethers_1 = require("@vechain/web3-providers-connex/dist/ethers");
(0, config_1.extendEnvironment)(hre => {
    if (hre.vechain === undefined) {
        if (hre.network.name.includes("vechain")) {
            throw new hardhat_vechain_1.VechainHardhatPluginError("vechain-ethers plugin requires hardhat-vechain");
        }
        else {
            return;
        }
    }
    hre.ethers = (0, plugins_1.lazyObject)(() => {
        const { ethers } = require("ethers");
        const { HardhatEthersProvider } = require("@nomicfoundation/hardhat-ethers/internal/hardhat-ethers-provider");
        var provider = new HardhatEthersProvider(hre.vechain, hre.network.name);
        provider.getNetwork = async function () {
            const chainId = await this.send("eth_chainId", []);
            const hexChainId = chainId.toString(16);
            // const smallChainId = '0x' + hexChainId.substring(hexChainId.length - 2);
            return new ethers.Network(hre.network.name, "0x" + hexChainId);
        };
        provider.getSigner = async (address) => {
            if (address === null || address === undefined) {
                address = 0;
            }
            const accountsPromise = provider.send("eth_accounts", []);
            // Account index
            if (typeof address === "number") {
                const accounts = await accountsPromise;
                if (address >= accounts.length) {
                    throw new Error(`Address index out of bounds: ${address}`);
                }
                let defaultSigner = await (0, helpers_1.getSigner)(hre, accounts[address]);
                defaultSigner.signTransaction = async (transaction) => {
                    return hre.vechain.sign(transaction);
                };
                return defaultSigner;
            }
            else {
                // If the address is a string, you might want to handle it differently or throw another error.
                throw new Error(`Unsupported address type: ${address}`);
            }
        };
        return {
            ...ethers,
            provider,
            getSigner: (address) => (0, helpers_1.getSigner)(hre, address),
            getSigners: () => (0, helpers_1.getSigners)(hre),
            getContractAtFromArtifact: helpers_1.getContractAtFromArtifact.bind(null, hre),
            getContractAt: helpers_1.getContractAt.bind(null, hre),
            getImpersonatedSigner: (address) => (0, helpers_1.getImpersonatedSigner)(hre, address),
            getContractFactory: ((...args) => {
                const bound = helpers_1.getContractFactory.bind(null, hre);
                return bound(...args).then(ethers_1.modifyFactory);
            }),
            getContractFactoryFromArtifact: ((...args) => {
                const bound = helpers_1.getContractFactoryFromArtifact.bind(null, hre);
                return bound(...args).then(ethers_1.modifyFactory);
            }),
            deployContract: helpers_1.deployContract.bind(null, hre),
        };
    });
});
//# sourceMappingURL=index.js.map