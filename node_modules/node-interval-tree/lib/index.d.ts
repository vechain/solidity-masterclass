export interface Interval<N extends number | bigint = number> {
    readonly low: N;
    readonly high: N;
}
export declare class Node<T extends Interval<N>, N extends number | bigint = number> {
    intervalTree: IntervalTree<T, N>;
    key: N;
    max: N;
    records: T[];
    parent?: Node<T, N>;
    height: number;
    left?: Node<T, N>;
    right?: Node<T, N>;
    constructor(intervalTree: IntervalTree<T, N>, record: T);
    getNodeHigh(): N;
    updateHeight(): void;
    updateMaxOfParents(): void;
    private _updateMaxAfterRightRotate;
    private _updateMaxAfterLeftRotate;
    private _leftRotate;
    private _rightRotate;
    private _rebalance;
    insert(record: T): void;
    private _getOverlappingRecords;
    search(low: N, high: N): T[];
    searchExisting(low: N): Node<T, N> | undefined;
    private _minValue;
    remove(node: Node<T, N>): Node<T, N> | undefined;
}
export declare class IntervalTree<T extends Interval<N>, N extends number | bigint = number> {
    root?: Node<T, N>;
    count: number;
    insert(record: T): boolean;
    search(low: N, high: N): T[];
    remove(record: T): boolean;
    inOrder(): InOrder<T, N>;
    reverseInOrder(): ReverseInOrder<T, N>;
    preOrder(): PreOrder<T, N>;
}
export interface DataInterval<T, N extends number | bigint = number> extends Interval<N> {
    data: T;
}
/**
 * The default export just wraps the `IntervalTree`, while providing a simpler API. Check out the
 * README for description on how to use each.
 */
export default class DataIntervalTree<T, N extends number | bigint = number> {
    private tree;
    insert(low: N, high: N, data: T): boolean;
    remove(low: N, high: N, data: T): boolean;
    search(low: N, high: N): T[];
    inOrder(): InOrder<DataInterval<T, N>, N>;
    reverseInOrder(): ReverseInOrder<DataInterval<T, N>, N>;
    preOrder(): PreOrder<DataInterval<T, N>, N>;
    get count(): number;
}
export declare class InOrder<T extends Interval<N>, N extends number | bigint = number> implements IterableIterator<T> {
    private stack;
    private currentNode?;
    private i;
    constructor(startNode?: Node<T, N>);
    [Symbol.iterator](): this;
    next(): IteratorResult<T>;
    private push;
    private pop;
}
export declare class ReverseInOrder<T extends Interval<N>, N extends number | bigint = number> implements IterableIterator<T> {
    private stack;
    private currentNode?;
    private i;
    constructor(startNode?: Node<T, N>);
    [Symbol.iterator](): this;
    next(): IteratorResult<T>;
    private push;
    private pop;
}
export declare class PreOrder<T extends Interval<N>, N extends number | bigint = number> implements IterableIterator<T> {
    private stack;
    private currentNode?;
    private i;
    constructor(startNode?: Node<T, N>);
    [Symbol.iterator](): this;
    next(): IteratorResult<T>;
    private push;
    private pop;
}
